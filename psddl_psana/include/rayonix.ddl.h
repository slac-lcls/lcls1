#ifndef PSANA_RAYONIX_DDL_H
#define PSANA_RAYONIX_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstring>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
namespace Psana {
namespace Rayonix {

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_RayonixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Row_Pixels = 3840 };
  enum { Column_Pixels = 3840 };
  enum { BasePixelSize = 44 };
  enum { DeviceIDMax = 40 };
  enum ReadoutMode {
    Standard = 0,
    HighGain = 1,
    LowNoise = 2,
    EDR = 3,
  };
  virtual ~ConfigV1();
  virtual uint8_t binning_f() const = 0;
  virtual uint8_t binning_s() const = 0;
  virtual uint32_t exposure() const = 0;
  virtual uint32_t trigger() const = 0;
  virtual uint16_t rawMode() const = 0;
  virtual uint16_t darkFlag() const = 0;
  virtual Rayonix::ConfigV1::ReadoutMode readoutMode() const = 0;
  virtual const char* deviceID() const = 0;
  /** The width of the pixels in um. */
  virtual uint32_t pixelWidth() const = 0;
  /** The height of the pixels in um. */
  virtual uint32_t pixelHeight() const = 0;
  /** Returns the maximum possible width in pixels (a.k.a unbinned). */
  virtual uint32_t maxWidth() const = 0;
  /** Returns the maximum possible height in pixels (a.k.a unbinned). */
  virtual uint32_t maxHeight() const = 0;
  /** Calculate the frame width in pixels based on the max number of pixels and the binning. */
  virtual uint32_t width() const = 0;
  /** Calculate the frame height in pixels based on the max number of pixels and the binning. */
  virtual uint32_t height() const = 0;
  /** calculate total frame size in pixels. */
  virtual uint32_t numPixels() const = 0;
};
std::ostream& operator<<(std::ostream& str, Rayonix::ConfigV1::ReadoutMode enval);

/** @class ConfigV2

  
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_RayonixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { MX340HS_Row_Pixels = 7680 };
  enum { MX340HS_Column_Pixels = 7680 };
  enum { MX170HS_Row_Pixels = 3840 };
  enum { MX170HS_Column_Pixels = 3840 };
  enum { BasePixelSize = 44 };
  enum { DeviceIDMax = 40 };
  enum ReadoutMode {
    Unknown = 0,
    Standard = 1,
    HighGain = 2,
    LowNoise = 3,
    HDR = 4,
  };
  virtual ~ConfigV2();
  virtual uint8_t binning_f() const = 0;
  virtual uint8_t binning_s() const = 0;
  virtual int16_t testPattern() const = 0;
  virtual uint32_t exposure() const = 0;
  virtual uint32_t trigger() const = 0;
  virtual uint16_t rawMode() const = 0;
  virtual uint16_t darkFlag() const = 0;
  virtual Rayonix::ConfigV2::ReadoutMode readoutMode() const = 0;
  virtual const char* deviceID() const = 0;
  /** The width of the pixels in um. */
  virtual uint32_t pixelWidth() const = 0;
  /** The height of the pixels in um. */
  virtual uint32_t pixelHeight() const = 0;
  /** Returns the maximum possible width in pixels (a.k.a unbinned). */
  virtual uint32_t maxWidth() const = 0;
  /** Returns the maximum possible height in pixels (a.k.a unbinned). */
  virtual uint32_t maxHeight() const = 0;
  /** Calculate the frame width in pixels based on the max number of pixels and the binning. */
  virtual uint32_t width() const = 0;
  /** Calculate the frame height in pixels based on the max number of pixels and the binning. */
  virtual uint32_t height() const = 0;
  /** calculate total frame size in pixels. */
  virtual uint32_t numPixels() const = 0;
};
std::ostream& operator<<(std::ostream& str, Rayonix::ConfigV2::ReadoutMode enval);
} // namespace Rayonix
} // namespace Psana
#endif // PSANA_RAYONIX_DDL_H
