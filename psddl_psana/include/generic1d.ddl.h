#ifndef PSANA_GENERIC1D_DDL_H
#define PSANA_GENERIC1D_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstring>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
namespace Psana {
namespace Generic1D {

/** @class ConfigV0

  
*/


class ConfigV0 {
public:
  enum { TypeId = Pds::TypeId::Id_Generic1DConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  enum Sample_Type {
    UINT8,
    UINT16,
    UINT32,
    FLOAT32,
    FLOAT64,
  };
  virtual ~ConfigV0();
  /** Number of channels */
  virtual uint32_t NChannels() const = 0;
  /** Waveform Length */
  virtual ndarray<const uint32_t, 1> Length() const = 0;
  /** Waveform Sample Type */
  virtual ndarray<const uint32_t, 1> SampleType() const = 0;
  /** Waveform Delay Samples */
  virtual ndarray<const int32_t, 1> Offset() const = 0;
  /** Waveform Sampling Period */
  virtual ndarray<const double, 1> Period() const = 0;
  virtual int32_t data_offset(uint32_t channel) const = 0;
  virtual uint32_t Depth(uint32_t channel) const = 0;
};
std::ostream& operator<<(std::ostream& str, Generic1D::ConfigV0::Sample_Type enval);

/** @class DataV0

  
*/

class ConfigV0;

class DataV0 {
public:
  enum { TypeId = Pds::TypeId::Id_Generic1DData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  virtual ~DataV0();
  virtual uint32_t data_size() const = 0;
  virtual ndarray<const uint8_t, 1> _int_data() const = 0;
  virtual ndarray<const uint8_t, 1> data_u8(uint32_t channel) const = 0;
  virtual ndarray<const uint16_t, 1> data_u16(uint32_t channel) const = 0;
  virtual ndarray<const uint32_t, 1> data_u32(uint32_t channel) const = 0;
  virtual ndarray<const float, 1> data_f32(uint32_t channel) const = 0;
  virtual ndarray<const double, 1> data_f64(uint32_t channel) const = 0;
};
} // namespace Generic1D
} // namespace Psana
#endif // PSANA_GENERIC1D_DDL_H
