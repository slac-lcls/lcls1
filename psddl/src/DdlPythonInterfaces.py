#--------------------------------------------------------------------------
# File and Version Information:
#  $Id: DdlPythonInterfaces.py 3643 2012-05-26 04:23:12Z jbarrera@SLAC.STANFORD.EDU $
#
# Description:
#  Module DdlPythonInterfaces...
#
#------------------------------------------------------------------------

"""DDL parser which generates psana C++ interfaces.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id: DdlPythonInterfaces.py 3643 2012-05-26 04:23:12Z jbarrera@SLAC.STANFORD.EDU $

@author Andrei Salnikov, Joseph S. Barrera III
"""
from __future__ import print_function


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision: 3643 $"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import types
import string
import re

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.Attribute import Attribute
from psddl.ExprVal import ExprVal
from psddl.Method import Method
from psddl.Package import Package
from psddl.Template import Template as T
from psddl.Enum import Enum
from psddl.Type import Type

#----------------------------------
# Local non-exported definitions --
#----------------------------------

def _interpolate(expr, typeobj):
    expr = expr.replace('{xtc-config}', 'cfg')
    expr = expr.replace('@config', 'cfg')
    expr = expr.replace('{type}.', typeobj.name+"::")
    expr = expr.replace('@type.', typeobj.name+"::")
    expr = expr.replace('{self}.', "this->")
    expr = expr.replace('@self.', "this->")
    return expr

def _typename(type, top_ns=None):
    if type is None: return 'void'
    return type.fullName('C++', top_ns)

def _typedecl(type, top_ns=None):
    typename = _typename(type, top_ns)
    if not type.basic : typename = "const "+typename+'&'
    return typename

def _argdecl(name, type):    
    return _typedecl(type) + ' ' + name

def _argdecl2(name, type):    
    return name

def _dims(dims):
    return ''.join(['[%s]'%d for d in dims])

def _dimargs(rank, type):
    int_type = type.lookup('uint32_t')
    return [('i%d'%i, int_type) for i in range(rank)]

def _dimexpr(dims):
    return ''.join(['[i%d]'%i for i in range(len(dims))])

def _escape_and_quote(comment):
    comment = comment.replace('\n','\\n')
    comment = comment.replace('"','\\"')
    return '"%s"'%comment
#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPythonInterfaces ( object ) :

    @staticmethod
    def backendOptions():
        """ Returns the list of options supported by this backend, returned value is 
        either None or a list of triplets (name, type, description)"""
        return [
            ('psana-inc', 'PATH', "directory for Psana includes, default: psddl_psana"),
            ('psana-ns', 'STRING', "namespace for Psana types, default: Psana"),
            ]

    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, backend_options, log ) :
        '''Constructor
        
           @param backend_options  dictionary of options passed to backend
           @param log              message logger instance
        '''
        self.incname = backend_options['global:header']
        self.cppname = backend_options['global:source']
        self.incdirname = backend_options.get('global:gen-incdir', "")
        self.top_pkg = backend_options.get('global:top-package')
        self.psana_inc = backend_options.get('psana-inc', "psddl_psana")
        self.psana_ns = backend_options.get('psana-ns', "Psana")
        self.generics = {}
        
        self._log = log

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.cpp = file(self.cppname, 'w')

        warning = "/* Do not edit this file, as it is auto-generated */\n"
        print(warning, file=self.cpp)

        # add necessary includes to include file
        print('#include <boost/python.hpp>', file=self.cpp)
        print('#include <boost/make_shared.hpp>', file=self.cpp)
        print('#include "ndarray/ndarray.h"', file=self.cpp)
        print('#include "pdsdata/xtc/TypeId.hh"', file=self.cpp)
        inc = os.path.join(self.psana_inc, os.path.basename(self.incname))
        print('#include "%s" // inc_psana' % inc, file=self.cpp)
        print('#include "psddl_python/Converter.h"', file=self.cpp)
        print('#include "psddl_python/DdlWrapper.h"', file=self.cpp)
        print('#include "psddl_python/ConverterMap.h"', file=self.cpp)
        print('#include "psddl_python/ConverterBoostDef.h"', file=self.cpp)
        print('#include "psddl_python/ConverterBoostDefSharedPtr.h"', file=self.cpp)
        print("", file=self.cpp)

        if self.top_pkg : 
            print(T("namespace $top_pkg {")[self], file=self.cpp)

        # loop over packages in the model
        for pkg in model.packages() :
            if not pkg.included :
                self._log.debug("parseTree: package=%s", repr(pkg))
                self._parsePackage(pkg)

        if self.top_pkg : 
            print(T("} // namespace $top_pkg")[self], file=self.cpp)

        # close all files
        self.cpp.close()

    def namespace_prefix(self):
        prefix = self.pkg.name + "::"
        if self.top_pkg: prefix = self.top_pkg + "::" + prefix
        return prefix

    def qualifiedConstantValue(self,constant):
        '''constant values sometimes reference previously defined 
        constants.  If the constant value is not numeric, we search the 
        parent namespaces to see if it is defined.  If so we qualify
        with the namespace found.  If not, it may be a valid expression for 
        code generation, so we just return it (so expressions like "4*34" 
        will be returned unmodified.
        '''
        value = constant.value
        try:            
            float(value) # this will not catch expressions like 4*17 or 0xFF
            return value
        except ValueError:
            enclosing = constant.parent
            while enclosing is not None:
                if type(enclosing) in [Type, Package]:
                    for constant in enclosing.constants():
                        if constant.name == value:
                            return enclosing.fullName('C++',self.psana_ns) + '::' + value
                    for enum in enclosing.enums():
                        for enum_constant in enum.constants():
                            if enum_constant.name == value:
                                return enclosing.fullName('C++',self.psana_ns) + '::' + value
                enclosing = enclosing.parent

        self._log.debug("Coud not find parent namespace for %s", value)
        return value

    def _parseEnum(self,enum):
        print(file=self.cpp)
        print(T('  enum_<$fullname>("$shortname")') \
                           (fullname=enum.fullName('C++',self.psana_ns),
                            shortname=enum.name), file=self.cpp)
        enclosingFullName = enum.parent.fullName('C++',self.psana_ns)
        for enum_constant in enum.constants():
            print(T('    .value("$constant",$enclosingFullName::$constant)') \
                                   (constant=enum_constant.name, enclosingFullName=enclosingFullName), file=self.cpp)
        print('  ;', file=self.cpp)

    def _parsePackage(self, pkgX):
        self.pkg = pkgX

        # open namespaces
        print(T("namespace $name {")[self.pkg], file=self.cpp)
        print("", file=self.cpp)
        print("using namespace boost::python;", file=self.cpp)
        print("using boost::python::object;", file=self.cpp)
        print("using boost::shared_ptr;", file=self.cpp)
        print("using std::vector;", file=self.cpp)
        print("", file=self.cpp)

        print('namespace {', file=self.cpp)
        print('template<typename T, std::vector<int> (T::*MF)() const>', file=self.cpp)
        print('PyObject* method_shape(const T *x) {', file=self.cpp)
        print('  return detail::vintToList((x->*MF)());\n}', file=self.cpp)
        print('} // namespace\n', file=self.cpp)


        print("void createWrappers(PyObject* module) {", file=self.cpp)

        # create sub-module for everything inside
        print(T('  DDL_CREATE_MODULE( "psana.$name", 0, "The Python wrapper module for $name types");')[self.pkg], file=self.cpp)
        print('  Py_INCREF(submodule);', file=self.cpp)
        print(T('  PyModule_AddObject(module, "$name", submodule);')[self.pkg], file=self.cpp)
        print('  scope mod = object(handle<>(borrowed(submodule)));', file=self.cpp)

        # expose any package level constants
        if len(self.pkg.constants())>0:
            print(file=self.cpp)
        for constant in self.pkg.constants():
            print(T('  mod.attr("$name")=$value;')(name=constant.name,
                                                               value=self.qualifiedConstantValue(constant)), file=self.cpp)

        # expose any package level enums:
        for enum in self.pkg.enums():
            self._parseEnum(enum)

        # loop over packages and types
        ndconverters = set()
        for ns in self.pkg.namespaces() :
            if isinstance(ns, Package) :
                print("Error: nested packages not supported:", ns)
                continue
            if isinstance(ns, Type) :
                self._parseType(ns, ndconverters)

        # make the unversioned objects containing versioned types
        unversioned2verMap = dict()
        typeNamesNotEndingWithVer = set()

        for type in self.pkg.namespaces() :
            if isinstance(type, Type) and type.version is not None:
                vstr = "V"+str(type.version)
                if type.name.endswith(vstr):
                    unvtype = type.name[:-len(vstr)]
                    unversioned2verMap.setdefault(unvtype, []).append(type.name)
                else:
                    typeNamesNotEndingWithVer.add(type.name)

        for nameNotEndingWithVer in typeNamesNotEndingWithVer:
            if nameNotEndingWithVer in unversioned2verMap:
                sys.stdout.write("DdlPythonInterfaces - info: %s is a type family including\n" % nameNotEndingWithVer)
                sys.stdout.write("  names ending with and without the version string.\n")
                sys.stdout.write("  Not generating the unversioned object containing the versioned types.\n")
                del unversioned2verMap[nameNotEndingWithVer]

        for unvtype, types in unversioned2verMap.items():
            print(T('  {\n    PyObject* unvlist = PyList_New($len);')(len=len(types)), file=self.cpp)
            for i, type in enumerate(types):
                print(T('    PyList_SET_ITEM(unvlist, $i, PyObject_GetAttrString(submodule, "$type"));')(locals()), file=self.cpp)
            print(T('    PyObject_SetAttrString(submodule, "$unvtype", unvlist);')(locals()), file=self.cpp)
            print(T('    Py_CLEAR(unvlist);\n  }')(locals()), file=self.cpp)


        for type, ndim in ndconverters:
            if ndim > 0:
                print(T('  detail::register_ndarray_to_numpy_cvt<const $type, $ndim>();')(locals()), file=self.cpp)
            else:
                print(T('  detail::register_ndarray_to_list_cvt<const $type>();')(locals()), file=self.cpp)

        # end createWrappers()
        print("", file=self.cpp)
        print("} // createWrappers()", file=self.cpp)

        # close namespaces
        print(T("} // namespace $name")[self.pkg], file=self.cpp)

    def _parseType(self, type, ndconverters):

        self._log.debug("_parseType: type=%s", repr(type))

        # skip included types
        if type.included : return

        self.codegen(type, ndconverters)

    def codegen(self, type, ndconverters):

        self._log.debug("codegen: type=%s", repr(type))
        #print "codegen: type=%s" % repr(type)

        # this class (class being generated)
        wrapped = type.fullName('C++', self.psana_ns)
        name = type.name + "_Wrapper"

        prefix = self.namespace_prefix()
        cname = type.name
        
        templ_args = [wrapped]
        if type.base:
            base = T('boost::python::bases<$base>')(base=type.base.fullName('C++', self.psana_ns))
            templ_args.append(base)
        if not type.value_type:
            holder = T('boost::shared_ptr<$wrapped>')(locals())
            templ_args += [holder, "boost::noncopyable"]
        templ_args = ', '.join(templ_args)
        
        pkgname = self.pkg.name

        has_nested_enums = len(type.enums()) > 0
        has_nested_constants = len(type.constants()) > 0
        has_version_or_type_id = type.version or type.type_id
        add_scoped_attributes = has_nested_enums or has_nested_constants or has_version_or_type_id
        if add_scoped_attributes:
            print('  {', file=self.cpp)
            print('  scope outer = ', file=self.cpp)

        if type.comment:
            type_comment = _escape_and_quote(type.comment)
            print(T('  class_<$templ_args >("$cname", $type_comment, no_init)')(locals()), file=self.cpp)
        else:
            print(T('  class_<$templ_args >("$cname", no_init)')(locals()), file=self.cpp)

        # generate methods (for public methods and abstract class methods only)
        for method in type.methods(): 
            if method.access == "public": self._genMethod(type, method, wrapped, ndconverters)

        # generate _shape() methods for array attributes
        for attr in type.attributes() :
            self._genAttrShapeAndListDecl(type, attr, wrapped)

        # close class declaration
        print('  ;', file=self.cpp)

        # write any nested enums, nested constants, version and type_id if present
        for enum in type.enums():
            self._parseEnum(enum)

        if type.version is not None:
            print(T('  scope().attr("Version")=$version;')(version=type.version), file=self.cpp)
        if type.type_id:
            print(T('  scope().attr("TypeId")=int(Pds::TypeId::$typeid);')(typeid=type.type_id), file=self.cpp)
            
        for constant in type.constants():
            print(T('  scope().attr("$name")=$value;')(name=constant.name,
                                                                   value=self.qualifiedConstantValue(constant)), file=self.cpp)
        if add_scoped_attributes:
            print('  }', file=self.cpp)

        # generates converter instance
        type_id = "Pds::TypeId::"+type.type_id if type.type_id is not None else -1
        if type.value_type:
            cvt_type = T('ConverterBoostDef<$wrapped> ')(locals()) 
        else:
            cvt_type = T('ConverterBoostDefSharedPtr<$wrapped> ')(locals()) 
        print(T('  ConverterMap::instance().addConverter(boost::make_shared<$cvt_type>($type_id));')(locals()), file=self.cpp)
        print("", file=self.cpp)

    def _genMethod(self, type, method, bclass, ndconverters):
        """Generate method declaration and definition"""

        self._log.debug("_genMethod: method: %s", method)
        
        method_name = method.name
        policy = None
        args = method.args
        margs = ', '.join([_argdecl2(*arg) for arg in args])
        
        if method_name == '_sizeof': 
            # not needed in Python
            return
        
        # generate code for a method
        if method.type is None:
            
            # method which does not return anything
            pass

        elif not method.rank:
            
            # attribute is a regular non-array object, it is returned by value or cref
            # non-basic types are returned by cref from wrapped method if method has 
            # corresponding attribute
            if method.attribute:
                if method.type.basic: 
                    policy = None
                elif method.type.value_type:
                    policy = "return_value_policy<copy_const_reference>()"
                else:
                    policy = "return_internal_reference<1>()"

        elif method.type.name == 'char':
            
            # char array is actually a string
            pass
            
        elif method.type.value_type and method.type.basic:
            
            # should also add boost converter for this ndarray type
            ctype = method.type.fullName('C++', self.psana_ns)
            if isinstance(method.type, Enum):
                ctype = method.type.base.fullName('C++', self.psana_ns)
            ndim = method.rank
            ndconverters.add((ctype, ndim))

        elif method.type.value_type:

            # wrapped method returns ndarray and we should convert it into regular Python list
            ctype = method.type.fullName('C++', self.psana_ns)
            ndconverters.add((ctype, -1))

        else:

            # array of non-value types, method will accept a set of indices.
            # wrapped method returns a const reference to an object wholly "contained" 
            # in the wrapped object, so set policy correctly. 
            policy = "return_internal_reference<>()"

        self._genMethodDef(type, bclass, method_name, method.comment, policy=policy)


    def _genMethodDef(self, type, bclass, method_name, method_comment, policy=''):

        policy = ', ' + policy if policy else ''
        if method_comment:
            method_comment = _escape_and_quote(method_comment)
            print(T('    .def("$method_name", &$bclass::$method_name$policy,$method_comment)')(locals()), file=self.cpp)
        else:
            print(T('    .def("$method_name", &$bclass::$method_name$policy)')(locals()), file=self.cpp)

    def isString(self, o):
        return type(o) == type("")

    def _genAttrShapeAndListDecl(self, type, attr, bclass):
        if not attr.shape_method: return
        if not attr.accessor: return
        
        # value-type arrays return ndarrays which do not need shape method
        if attr.type.value_type and attr.type.name != 'char': return

        # generate shape method
        shape_method = attr.shape_method
        print(T('    .def("$shape_method", &method_shape<$bclass, &$bclass::$shape_method>)')(locals()), file=self.cpp)

#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
