#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Module DdlPdsdata...
#
#------------------------------------------------------------------------

"""DDL parser which generates pdsdata C++ code.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id$

@author Andrei Salnikov
"""
from __future__ import print_function


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import types

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.JinjaEnvironment import getJinjaEnvironment
from psddl.CppTypeCodegen import CppTypeCodegen
from psddl.Package import Package
from psddl.Type import Type

#----------------------------------
# Local non-exported definitions --
#----------------------------------

# jinja environment
_jenv = getJinjaEnvironment()

def _TEMPL(template):
    return _jenv.get_template('cppcodegen.tmpl?'+template)

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPdsdata ( object ) :

    @staticmethod
    def backendOptions():
        """ Returns the list of options supported by this backend, returned value is 
        either None or a list of triplets (name, type, description)"""
        return None

    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, backend_options, log ) :
        '''Constructor
        
           @param backend_options  dictionary of options passed to backend
           @param log              message logger instance
        '''
        self.incname = backend_options['global:header']
        self.cppname = backend_options['global:source']
        self.incdirname = backend_options.get('global:gen-incdir', "")
        self.top_pkg = backend_options.get('global:top-package')
        
        self._log = log 
        
        #include guard
        g = os.path.split(self.incname)[1]
        if self.top_pkg: g = self.top_pkg + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')
        
        # include guard to header
        print("#ifndef", self.guard, file=self.inc) 
        print("#define", self.guard, "1", file=self.inc)

        msg = "\n// *** Do not edit this file, it is auto-generated ***\n"
        print(msg, file=self.inc)
        print(msg, file=self.cpp)

        # add necessary includes
        print("#include <vector>", file=self.inc)
        print("#include <iosfwd>", file=self.inc)
        print("#include <cstddef>", file=self.inc)
        print("#include <cstring>", file=self.inc)
        print("#include \"pdsdata/xtc/TypeId.hh\"", file=self.inc)
        print("#include \"ndarray/ndarray.h\"", file=self.inc)

        inc = os.path.join(self.incdirname, os.path.basename(self.incname))
        print("#include \"%s\"\n" % inc, file=self.cpp)
        print("#include <iostream>", file=self.cpp)

        # headers for other included packages
        for use in model.use:
            path = use['file']
            headers = use['cpp_headers']
            if not headers:
                header = os.path.splitext(path)[0]
                if not header.endswith('.ddl'): header += '.ddl'
                header = header + '.h'
                header = os.path.join(self.incdirname, os.path.basename(header))
                headers = [header]
            for header in headers:
                print("#include \"%s\"" % header, file=self.inc)

        if self.top_pkg : 
            print("namespace %s {" % self.top_pkg, file=self.inc)
            print("namespace %s {" % self.top_pkg, file=self.cpp)

        # enums for constants
        for const in model.constants() :
            if not const.included :
                self._genConst(const)

        # regular enums
        for enum in model.enums() :
            if not enum.included :
                self._genEnum(enum)

        # loop over packages and types in the model
        for ns in model.namespaces() :
            if isinstance(ns, Package) :
                self._parsePackage(ns)
            elif isinstance(ns, Type) :
                if not ns.external:
                    self._parseType(type = ns)

        if self.top_pkg : 
            print("} // namespace %s" % self.top_pkg, file=self.inc)
            print("} // namespace %s" % self.top_pkg, file=self.cpp)

        # close include guard
        print("#endif //", self.guard, file=self.inc)

        # close all files
        self.inc.close()
        self.cpp.close()


    def _parsePackage(self, pkg):

        if pkg.included: return

        # open namespaces
        print("namespace %s {" % pkg.name, file=self.inc)
        print("namespace %s {" % pkg.name, file=self.cpp)

        # enums for constants
        for const in pkg.constants() :
            if not const.included :
                self._genConst(const)

        # regular enums
        for enum in pkg.enums() :
            if not enum.included :
                self._genEnum(enum)

        # loop over packages and types
        for ns in pkg.namespaces() :
            
            if isinstance(ns, Package) :
                
                self._parsePackage(ns)
            
            elif isinstance(ns, Type) :
    
                self._parseType(type = ns)

        # close namespaces
        print("} // namespace %s" % pkg.name, file=self.inc)
        print("} // namespace %s" % pkg.name, file=self.cpp)

    def _parseType(self, type):

        self._log.debug("_parseType: type=%s", repr(type))

        # skip included types
        if type.included : return

        # check for tag combinations that don't make sense
        if 'config' in type.tags and 'value-type' in type.tags:
            DDL_FORCE = os.environ.get('DDL_FORCE',0)
            if DDL_FORCE:
                msg = "DDL_FORCE: allowing value_type and config(...) "
                msg += "tag combinations for %s" % type.fullName()
                print(msg)
            else:
                msg = "The type %s has both the tags" % type.fullName()
                msg += " [[value_type]] and [[config(...)]]."
                msg += " This will probably break psana code generation."
                msg += " Removing the [[value_type]] will fix this."
                msg += " If you are sure using both tags is correct,"
                msg += " set the environment variable DDL_FORCE=1"
                raise Exception(msg)

        codegen = CppTypeCodegen(self.inc, self.cpp, type, pdsdata=True)
        codegen.codegen()

    def _genConst(self, const):
        
        print("  enum {\n    %s = %s /**< %s */\n  };" % \
                (const.name, const.value, const.comment), file=self.inc)

    def _genEnum(self, enum):

        if enum.comment: print("\n  /** %s */" % (enum.comment), file=self.inc)
        print("  enum %s {" % (enum.name or "",), file=self.inc)
        for const in enum.constants() :
            val = ""
            if const.value is not None : val = " = " + const.value
            doc = ""
            if const.comment: doc = ' /**< %s */' % const.comment
            print("    %s%s,%s" % (const.name, val, doc), file=self.inc)
        print("  };", file=self.inc)
        
        if enum.name:
            print(_TEMPL('enum_print_decl').render(locals()), file=self.inc)
            print(_TEMPL('enum_print_impl').render(locals()), file=self.cpp)


#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
