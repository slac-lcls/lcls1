
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/generic1d.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
#include "psddl_hdf2psana/generic1d.h"
namespace psddl_hdf2psana {
namespace Generic1D {

hdf5pp::Type ns_ConfigV0_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV0_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("NChannels", offsetof(DsType, NChannels), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV0_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV0_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV0_v0_dataset_config_native_type()
{
  typedef ns_ConfigV0_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("NChannels", offsetof(DsType, NChannels), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV0_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV0_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV0_v0::dataset_config::dataset_config()
{
}

ns_ConfigV0_v0::dataset_config::dataset_config(const Psana::Generic1D::ConfigV0& psanaobj)
  : NChannels(psanaobj.NChannels())
{
}

ns_ConfigV0_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV0_v0::NChannels() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->NChannels);
}
ndarray<const uint32_t, 1> ConfigV0_v0::Length() const {
  if (m_ds_Length.empty()) read_ds_Length();
  return m_ds_Length;
}
ndarray<const uint32_t, 1> ConfigV0_v0::SampleType() const {
  if (m_ds_SampleType.empty()) read_ds_SampleType();
  return m_ds_SampleType;
}
ndarray<const int32_t, 1> ConfigV0_v0::Offset() const {
  if (m_ds_Offset.empty()) read_ds_Offset();
  return m_ds_Offset;
}
ndarray<const double, 1> ConfigV0_v0::Period() const {
  if (m_ds_Period.empty()) read_ds_Period();
  return m_ds_Period;
}
int32_t ConfigV0_v0::data_offset(uint32_t channel) const {
  if (m_ds_data_offset.empty()) read_ds_data_offset();
  return m_ds_data_offset[ channel ];
}
uint32_t ConfigV0_v0::Depth(uint32_t channel) const {
  if (m_ds_Depth.empty()) read_ds_Depth();
  return m_ds_Depth[ channel ];
}
void ConfigV0_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<Generic1D::ns_ConfigV0_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV0_v0::read_ds_Length() const {
  m_ds_Length = hdf5pp::Utils::readNdarray<uint32_t, 1>(m_group, "Length", m_idx);
}
void ConfigV0_v0::read_ds_SampleType() const {
  m_ds_SampleType = hdf5pp::Utils::readNdarray<uint32_t, 1>(m_group, "SampleType", m_idx);
}
void ConfigV0_v0::read_ds_Offset() const {
  m_ds_Offset = hdf5pp::Utils::readNdarray<int32_t, 1>(m_group, "Offset", m_idx);
}
void ConfigV0_v0::read_ds_Period() const {
  m_ds_Period = hdf5pp::Utils::readNdarray<double, 1>(m_group, "Period", m_idx);
}
void ConfigV0_v0::read_ds_data_offset() const {
  m_ds_data_offset = hdf5pp::Utils::readNdarray<int32_t, 1>(m_group, "data_offset", m_idx);
}
void ConfigV0_v0::read_ds_Depth() const {
  m_ds_Depth = hdf5pp::Utils::readNdarray<uint32_t, 1>(m_group, "Depth", m_idx);
}

void make_datasets_ConfigV0_v0(const Psana::Generic1D::ConfigV0& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Generic1D::ns_ConfigV0_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.Length()) PsanaArray;
    const PsanaArray& psana_array = obj.Length();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint32_t>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "Length", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.SampleType()) PsanaArray;
    const PsanaArray& psana_array = obj.SampleType();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint32_t>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "SampleType", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.Offset()) PsanaArray;
    const PsanaArray& psana_array = obj.Offset();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<int32_t>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "Offset", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.Period()) PsanaArray;
    const PsanaArray& psana_array = obj.Period();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<double>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "Period", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<int32_t>::stored_type(), obj.NChannels());
    hdf5pp::Utils::createDataset(group, "data_offset", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint32_t>::stored_type(), obj.NChannels());
    hdf5pp::Utils::createDataset(group, "Depth", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV0_v0(const Psana::Generic1D::ConfigV0* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Generic1D::ns_ConfigV0_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "Length", obj->Length(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "Length", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "Length", obj->Length());
  }

  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "SampleType", obj->SampleType(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "SampleType", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "SampleType", obj->SampleType());
  }

  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "Offset", obj->Offset(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "Offset", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "Offset", obj->Offset());
  }

  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "Period", obj->Period(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "Period", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "Period", obj->Period());
  }

  if (append) {
    if (obj) {
      ndarray<int32_t, 1> data_offset_method_domain = make_ndarray<int32_t>(obj->NChannels());
      for (uint32_t methodArg = 0; methodArg < obj->NChannels(); ++methodArg) {
        data_offset_method_domain[methodArg] = obj->data_offset(methodArg);
      }
      hdf5pp::Utils::storeNDArrayAt(group, "data_offset", data_offset_method_domain, index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "data_offset", index < 0 ? index : index + 1);
    }
  } else {
    ndarray<int32_t, 1> data_offset_method_domain = make_ndarray<int32_t>(obj->NChannels());
    for (uint32_t methodArg = 0; methodArg < obj->NChannels(); ++methodArg) {
      data_offset_method_domain[methodArg] = obj->data_offset(methodArg);
    }
    hdf5pp::Utils::storeNDArray(group, "data_offset", data_offset_method_domain);
  }

  if (append) {
    if (obj) {
      ndarray<uint32_t, 1> Depth_method_domain = make_ndarray<uint32_t>(obj->NChannels());
      for (uint32_t methodArg = 0; methodArg < obj->NChannels(); ++methodArg) {
        Depth_method_domain[methodArg] = obj->Depth(methodArg);
      }
      hdf5pp::Utils::storeNDArrayAt(group, "Depth", Depth_method_domain, index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "Depth", index < 0 ? index : index + 1);
    }
  } else {
    ndarray<uint32_t, 1> Depth_method_domain = make_ndarray<uint32_t>(obj->NChannels());
    for (uint32_t methodArg = 0; methodArg < obj->NChannels(); ++methodArg) {
      Depth_method_domain[methodArg] = obj->Depth(methodArg);
    }
    hdf5pp::Utils::storeNDArray(group, "Depth", Depth_method_domain);
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::Generic1D::ConfigV0> > make_ConfigV0(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Generic1D::ConfigV0> >(boost::make_shared<ConfigV0_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Generic1D::ConfigV0> >(boost::shared_ptr<Psana::Generic1D::ConfigV0>());
  }
}

void make_datasets(const Psana::Generic1D::ConfigV0& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV0_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Generic1D.ConfigV0", version);
  }
}

void store_ConfigV0(const Psana::Generic1D::ConfigV0* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV0_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Generic1D.ConfigV0", version);
  }
}

void store(const Psana::Generic1D::ConfigV0& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV0(&obj, group, 0, version, false);
}

void store_at(const Psana::Generic1D::ConfigV0* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV0(obj, group, index, version, true);
}

boost::shared_ptr<PSEvt::Proxy<Psana::Generic1D::DataV0> > make_DataV0(int version, hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Psana::Generic1D::ConfigV0>& cfg) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Generic1D::DataV0> >(boost::make_shared<DataV0_v0<Psana::Generic1D::ConfigV0> >(group, idx, cfg));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Generic1D::DataV0> >(boost::shared_ptr<Psana::Generic1D::DataV0>());
  }
}

void make_datasets(const Psana::Generic1D::DataV0& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_DataV0_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Generic1D.DataV0", version);
  }
}

void store_DataV0(const Psana::Generic1D::DataV0* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_DataV0_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Generic1D.DataV0", version);
  }
}

void store(const Psana::Generic1D::DataV0& obj, hdf5pp::Group group, int version) 
{
  store_DataV0(&obj, group, 0, version, false);
}

void store_at(const Psana::Generic1D::DataV0* obj, hdf5pp::Group group, long index, int version)
{
  store_DataV0(obj, group, index, version, true);
}

} // namespace Generic1D
} // namespace psddl_hdf2psana
