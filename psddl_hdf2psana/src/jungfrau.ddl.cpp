
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/jungfrau.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
namespace psddl_hdf2psana {
namespace Jungfrau {

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("numberOfModules", offsetof(DsType, numberOfModules), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numberOfRowsPerModule", offsetof(DsType, numberOfRowsPerModule), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numberOfColumnsPerModule", offsetof(DsType, numberOfColumnsPerModule), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("biasVoltage", offsetof(DsType, biasVoltage), hdf5pp::TypeTraits<uint32_t>::stored_type());
  hdf5pp::EnumType<uint16_t> _enum_type_gainMode = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_gainMode.insert("Normal", Psana::Jungfrau::ConfigV1::Normal);
  _enum_type_gainMode.insert("FixedGain1", Psana::Jungfrau::ConfigV1::FixedGain1);
  _enum_type_gainMode.insert("FixedGain2", Psana::Jungfrau::ConfigV1::FixedGain2);
  _enum_type_gainMode.insert("ForcedGain1", Psana::Jungfrau::ConfigV1::ForcedGain1);
  _enum_type_gainMode.insert("ForcedGain2", Psana::Jungfrau::ConfigV1::ForcedGain2);
  _enum_type_gainMode.insert("HighGain0", Psana::Jungfrau::ConfigV1::HighGain0);
  type.insert("gainMode", offsetof(DsType, gainMode), _enum_type_gainMode);
  hdf5pp::EnumType<uint16_t> _enum_type_speedMode = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_speedMode.insert("Quarter", Psana::Jungfrau::ConfigV1::Quarter);
  _enum_type_speedMode.insert("Half", Psana::Jungfrau::ConfigV1::Half);
  type.insert("speedMode", offsetof(DsType, speedMode), _enum_type_speedMode);
  type.insert("triggerDelay", offsetof(DsType, triggerDelay), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("exposureTime", offsetof(DsType, exposureTime), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("frameSize", offsetof(DsType, frameSize), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numPixels", offsetof(DsType, numPixels), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("numberOfModules", offsetof(DsType, numberOfModules), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numberOfRowsPerModule", offsetof(DsType, numberOfRowsPerModule), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numberOfColumnsPerModule", offsetof(DsType, numberOfColumnsPerModule), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("biasVoltage", offsetof(DsType, biasVoltage), hdf5pp::TypeTraits<uint32_t>::native_type());
  hdf5pp::EnumType<uint16_t> _enum_type_gainMode = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_gainMode.insert("Normal", Psana::Jungfrau::ConfigV1::Normal);
  _enum_type_gainMode.insert("FixedGain1", Psana::Jungfrau::ConfigV1::FixedGain1);
  _enum_type_gainMode.insert("FixedGain2", Psana::Jungfrau::ConfigV1::FixedGain2);
  _enum_type_gainMode.insert("ForcedGain1", Psana::Jungfrau::ConfigV1::ForcedGain1);
  _enum_type_gainMode.insert("ForcedGain2", Psana::Jungfrau::ConfigV1::ForcedGain2);
  _enum_type_gainMode.insert("HighGain0", Psana::Jungfrau::ConfigV1::HighGain0);
  type.insert("gainMode", offsetof(DsType, gainMode), _enum_type_gainMode);
  hdf5pp::EnumType<uint16_t> _enum_type_speedMode = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_speedMode.insert("Quarter", Psana::Jungfrau::ConfigV1::Quarter);
  _enum_type_speedMode.insert("Half", Psana::Jungfrau::ConfigV1::Half);
  type.insert("speedMode", offsetof(DsType, speedMode), _enum_type_speedMode);
  type.insert("triggerDelay", offsetof(DsType, triggerDelay), hdf5pp::TypeTraits<double>::native_type());
  type.insert("exposureTime", offsetof(DsType, exposureTime), hdf5pp::TypeTraits<double>::native_type());
  type.insert("frameSize", offsetof(DsType, frameSize), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numPixels", offsetof(DsType, numPixels), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV1_v0::dataset_config::dataset_config()
{
}

ns_ConfigV1_v0::dataset_config::dataset_config(const Psana::Jungfrau::ConfigV1& psanaobj)
  : numberOfModules(psanaobj.numberOfModules())
  , numberOfRowsPerModule(psanaobj.numberOfRowsPerModule())
  , numberOfColumnsPerModule(psanaobj.numberOfColumnsPerModule())
  , biasVoltage(psanaobj.biasVoltage())
  , gainMode(psanaobj.gainMode())
  , speedMode(psanaobj.speedMode())
  , triggerDelay(psanaobj.triggerDelay())
  , exposureTime(psanaobj.exposureTime())
  , frameSize(psanaobj.frameSize())
  , numPixels(psanaobj.numPixels())
{
}

ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV1_v0::numberOfModules() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfModules);
}
uint32_t ConfigV1_v0::numberOfRowsPerModule() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfRowsPerModule);
}
uint32_t ConfigV1_v0::numberOfColumnsPerModule() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfColumnsPerModule);
}
uint32_t ConfigV1_v0::biasVoltage() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->biasVoltage);
}
Psana::Jungfrau::ConfigV1::GainMode ConfigV1_v0::gainMode() const {
  if (not m_ds_config) read_ds_config();
  return Psana::Jungfrau::ConfigV1::GainMode(m_ds_config->gainMode);
}
Psana::Jungfrau::ConfigV1::SpeedMode ConfigV1_v0::speedMode() const {
  if (not m_ds_config) read_ds_config();
  return Psana::Jungfrau::ConfigV1::SpeedMode(m_ds_config->speedMode);
}
double ConfigV1_v0::triggerDelay() const {
  if (not m_ds_config) read_ds_config();
  return double(m_ds_config->triggerDelay);
}
double ConfigV1_v0::exposureTime() const {
  if (not m_ds_config) read_ds_config();
  return double(m_ds_config->exposureTime);
}
uint32_t ConfigV1_v0::frameSize() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->frameSize);
}
uint32_t ConfigV1_v0::numPixels() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numPixels);
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<Jungfrau::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}

void make_datasets_ConfigV1_v0(const Psana::Jungfrau::ConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Jungfrau::ns_ConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV1_v0(const Psana::Jungfrau::ConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Jungfrau::ns_ConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Jungfrau::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Jungfrau::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Jungfrau::ConfigV1> >(boost::shared_ptr<Psana::Jungfrau::ConfigV1>());
  }
}

void make_datasets(const Psana::Jungfrau::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Jungfrau.ConfigV1", version);
  }
}

void store_ConfigV1(const Psana::Jungfrau::ConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Jungfrau.ConfigV1", version);
  }
}

void store(const Psana::Jungfrau::ConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Jungfrau::ConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_ElementV1_v0_dataset_data_stored_type()
{
  typedef ns_ElementV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("frameNumber", offsetof(DsType, frameNumber), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("ticks", offsetof(DsType, ticks), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("fiducials", offsetof(DsType, fiducials), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ElementV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_ElementV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_ElementV1_v0_dataset_data_native_type()
{
  typedef ns_ElementV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("frameNumber", offsetof(DsType, frameNumber), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("ticks", offsetof(DsType, ticks), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("fiducials", offsetof(DsType, fiducials), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ElementV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_ElementV1_v0_dataset_data_native_type();
  return type;
}

ns_ElementV1_v0::dataset_data::dataset_data()
{
}

ns_ElementV1_v0::dataset_data::dataset_data(const Psana::Jungfrau::ElementV1& psanaobj)
  : frameNumber(psanaobj.frameNumber())
  , ticks(psanaobj.ticks())
  , fiducials(psanaobj.fiducials())
{
}

ns_ElementV1_v0::dataset_data::~dataset_data()
{
}
template <typename Config>
uint32_t ElementV1_v0<Config>::frameNumber() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->frameNumber);
}
template <typename Config>
uint32_t ElementV1_v0<Config>::ticks() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->ticks);
}
template <typename Config>
uint32_t ElementV1_v0<Config>::fiducials() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->fiducials);
}
template <typename Config>
ndarray<const uint16_t, 3> ElementV1_v0<Config>::frame() const {
  if (m_ds_frame.empty()) read_ds_frame();
  return m_ds_frame;
}
template <typename Config>
void ElementV1_v0<Config>::read_ds_data() const {
  m_ds_data = hdf5pp::Utils::readGroup<Jungfrau::ns_ElementV1_v0::dataset_data>(m_group, "data", m_idx);
}
template <typename Config>
void ElementV1_v0<Config>::read_ds_frame() const {
  m_ds_frame = hdf5pp::Utils::readNdarray<uint16_t, 3>(m_group, "frame", m_idx);
}
template class ElementV1_v0<Psana::Jungfrau::ConfigV1>;

void make_datasets_ElementV1_v0(const Psana::Jungfrau::ElementV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Jungfrau::ns_ElementV1_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "data", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.frame()) PsanaArray;
    const PsanaArray& psana_array = obj.frame();
    hsize_t dims[3];
    std::copy(psana_array.shape(), psana_array.shape()+3, dims);
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint16_t>::stored_type(), 3, dims);
    hdf5pp::Utils::createDataset(group, "frame", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ElementV1_v0(const Psana::Jungfrau::ElementV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Jungfrau::ns_ElementV1_v0::dataset_data ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "data", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "data", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "data", index < 0 ? index : index + 1);
  }
  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "frame", obj->frame(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "frame", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "frame", obj->frame());
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::Jungfrau::ElementV1> > make_ElementV1(int version, hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Psana::Jungfrau::ConfigV1>& cfg) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Jungfrau::ElementV1> >(boost::make_shared<ElementV1_v0<Psana::Jungfrau::ConfigV1> >(group, idx, cfg));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Jungfrau::ElementV1> >(boost::shared_ptr<Psana::Jungfrau::ElementV1>());
  }
}

void make_datasets(const Psana::Jungfrau::ElementV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ElementV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Jungfrau.ElementV1", version);
  }
}

void store_ElementV1(const Psana::Jungfrau::ElementV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ElementV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Jungfrau.ElementV1", version);
  }
}

void store(const Psana::Jungfrau::ElementV1& obj, hdf5pp::Group group, int version) 
{
  store_ElementV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Jungfrau::ElementV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ElementV1(obj, group, index, version, true);
}

} // namespace Jungfrau
} // namespace psddl_hdf2psana
