#ifndef PDS_ANDOR_DDL_H
#define PDS_ANDOR_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Andor {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_AndorConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum EnumFanMode {
    ENUM_FAN_FULL = 0,
    ENUM_FAN_LOW = 1,
    ENUM_FAN_OFF = 2,
    ENUM_FAN_ACQOFF = 3,
    ENUM_FAN_NUM = 4,
  };
  ConfigV1(uint32_t arg__uWidth, uint32_t arg__uHeight, uint32_t arg__uOrgX, uint32_t arg__uOrgY, uint32_t arg__uBinX, uint32_t arg__uBinY, float arg__f32ExposureTime, float arg__f32CoolingTemp, Andor::ConfigV1::EnumFanMode arg__u8FanMode, uint8_t arg__u8BaselineClamp, uint8_t arg__u8HighCapacity, uint8_t arg__u8GainIndex, uint16_t arg__u16ReadoutSpeedIndex, uint16_t arg__u16ExposureEventCode, uint32_t arg__u32NumDelayShots)
    : _uWidth(arg__uWidth), _uHeight(arg__uHeight), _uOrgX(arg__uOrgX), _uOrgY(arg__uOrgY), _uBinX(arg__uBinX), _uBinY(arg__uBinY), _f32ExposureTime(arg__f32ExposureTime), _f32CoolingTemp(arg__f32CoolingTemp), _u8FanMode(arg__u8FanMode), _u8BaselineClamp(arg__u8BaselineClamp), _u8HighCapacity(arg__u8HighCapacity), _u8GainIndex(arg__u8GainIndex), _u16ReadoutSpeedIndex(arg__u16ReadoutSpeedIndex), _u16ExposureEventCode(arg__u16ExposureEventCode), _u32NumDelayShots(arg__u32NumDelayShots)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  Andor::ConfigV1::EnumFanMode fanMode() const { return Andor::ConfigV1::EnumFanMode(_u8FanMode); }
  uint8_t baselineClamp() const { return _u8BaselineClamp; }
  uint8_t highCapacity() const { return _u8HighCapacity; }
  uint8_t gainIndex() const { return _u8GainIndex; }
  uint16_t readoutSpeedIndex() const { return _u16ReadoutSpeedIndex; }
  uint16_t exposureEventCode() const { return _u16ExposureEventCode; }
  uint32_t numDelayShots() const { return _u32NumDelayShots; }
  /** Total size in bytes of the Frame object */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (width() + binX() - 1) / binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (height() + binY() - 1) / binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return numPixelsX()*numPixelsY(); }
  static uint32_t _sizeof() { return 44; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint8_t	_u8FanMode;
  uint8_t	_u8BaselineClamp;
  uint8_t	_u8HighCapacity;
  uint8_t	_u8GainIndex;
  uint16_t	_u16ReadoutSpeedIndex;
  uint16_t	_u16ExposureEventCode;
  uint32_t	_u32NumDelayShots;
};
std::ostream& operator<<(std::ostream& str, Andor::ConfigV1::EnumFanMode enval);
#pragma pack(pop)

/** @class ConfigV2

  
*/

#pragma pack(push,4)

class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_AndorConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum EnumFanMode {
    ENUM_FAN_FULL = 0,
    ENUM_FAN_LOW = 1,
    ENUM_FAN_OFF = 2,
    ENUM_FAN_ACQOFF = 3,
    ENUM_FAN_NUM = 4,
  };
  enum EnumCropMode {
    ENUM_CROP_OFF = 0,
    ENUM_CROP_ON = 1,
    ENUM_CROP_EX = 2,
    ENUM_CROP_NUM = 3,
  };
  ConfigV2(uint32_t arg__uWidth, uint32_t arg__uHeight, uint32_t arg__uOrgX, uint32_t arg__uOrgY, uint32_t arg__uBinX, uint32_t arg__uBinY, float arg__f32ExposureTime, float arg__f32CoolingTemp, Andor::ConfigV2::EnumFanMode arg__u8FanMode, Andor::ConfigV2::EnumCropMode arg__u8CropMode, uint8_t arg__u8BaselineClamp, uint8_t arg__u8HighCapacity, uint8_t arg__u8GainIndex, uint16_t arg__u16ReadoutSpeedIndex, uint16_t arg__u16ExposureEventCode, uint32_t arg__u32NumDelayShots)
    : _uWidth(arg__uWidth), _uHeight(arg__uHeight), _uOrgX(arg__uOrgX), _uOrgY(arg__uOrgY), _uBinX(arg__uBinX), _uBinY(arg__uBinY), _f32ExposureTime(arg__f32ExposureTime), _f32CoolingTemp(arg__f32CoolingTemp), _u8FanMode(arg__u8FanMode), _u8CropMode(arg__u8CropMode), _u8BaselineClamp(arg__u8BaselineClamp), _u8HighCapacity(arg__u8HighCapacity), _u8GainIndex(arg__u8GainIndex), _u16ReadoutSpeedIndex(arg__u16ReadoutSpeedIndex), _u16ExposureEventCode(arg__u16ExposureEventCode), _u32NumDelayShots(arg__u32NumDelayShots)
  {
  }
  ConfigV2() {}
  ConfigV2(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV2& operator=(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  Andor::ConfigV2::EnumFanMode fanMode() const { return Andor::ConfigV2::EnumFanMode(_u8FanMode); }
  Andor::ConfigV2::EnumCropMode cropMode() const { return Andor::ConfigV2::EnumCropMode(_u8CropMode); }
  uint8_t baselineClamp() const { return _u8BaselineClamp; }
  uint8_t highCapacity() const { return _u8HighCapacity; }
  uint8_t gainIndex() const { return _u8GainIndex; }
  uint16_t readoutSpeedIndex() const { return _u16ReadoutSpeedIndex; }
  uint16_t exposureEventCode() const { return _u16ExposureEventCode; }
  uint32_t numDelayShots() const { return _u32NumDelayShots; }
  /** Total size in bytes of the Frame object */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (width() + binX() - 1) / binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (height() + binY() - 1) / binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return numPixelsX()*numPixelsY(); }
  static uint32_t _sizeof() { return 48; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint16_t	_u8FanMode;
  uint16_t	_u8CropMode;
  uint8_t	_u8BaselineClamp;
  uint8_t	_u8HighCapacity;
  uint8_t	_u8GainIndex;
  uint8_t	_pad1;
  uint16_t	_u16ReadoutSpeedIndex;
  uint16_t	_u16ExposureEventCode;
  uint32_t	_u32NumDelayShots;
};
std::ostream& operator<<(std::ostream& str, Andor::ConfigV2::EnumFanMode enval);
std::ostream& operator<<(std::ostream& str, Andor::ConfigV2::EnumCropMode enval);
#pragma pack(pop)

/** @class FrameV1

  
*/

class ConfigV1;
class ConfigV2;
#pragma pack(push,4)

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_AndorFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  FrameV1(uint32_t iShotIdStart, float fReadoutTime, float fTemperature)
    : _iShotIdStart(iShotIdStart), _fReadoutTime(fReadoutTime), _fTemperature(fTemperature)
  {
  }
  FrameV1() {}
private:
  FrameV1(const FrameV1&);
  FrameV1& operator=(const FrameV1&);
public:
  uint32_t shotIdStart() const { return _iShotIdStart; }
  float readoutTime() const { return _fReadoutTime; }
  float temperature() const { return _fTemperature; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> data(const Andor::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=12;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numPixelsY(), cfg.numPixelsX());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> data(const Andor::ConfigV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=12;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numPixelsY(), cfg.numPixelsX());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> data(const Andor::ConfigV1& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> data(const Andor::ConfigV2& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  static uint32_t _sizeof(const Andor::ConfigV1& cfg) { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Andor::ConfigV2& cfg) { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
private:
  uint32_t	_iShotIdStart;
  float	_fReadoutTime;
  float	_fTemperature;
  //uint16_t	_data[cfg.numPixelsY()][cfg.numPixelsX()];
};
#pragma pack(pop)
} // namespace Andor
} // namespace Pds
#endif // PDS_ANDOR_DDL_H
