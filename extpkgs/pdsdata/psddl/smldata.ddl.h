#ifndef PDS_SMLDATA_DDL_H
#define PDS_SMLDATA_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
namespace Pds {
namespace SmlData {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SmlDataConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ConfigV1(uint32_t arg__sizeThreshold)
    : _sizeThreshold(arg__sizeThreshold)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t sizeThreshold() const { return _sizeThreshold; }
  static uint32_t _sizeof() { return 4; }
private:
  uint32_t	_sizeThreshold;
};
#pragma pack(pop)

/** @class OrigDgramOffsetV1

  
*/

class ConfigV1;
#pragma pack(push,4)

class OrigDgramOffsetV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SmlDataOrigDgramOffset /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  OrigDgramOffsetV1(int64_t arg__fileOffset, uint32_t arg__extent)
    : _fileOffset(arg__fileOffset), _extent(arg__extent)
  {
  }
  OrigDgramOffsetV1() {}
  OrigDgramOffsetV1(const OrigDgramOffsetV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  OrigDgramOffsetV1& operator=(const OrigDgramOffsetV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  int64_t fileOffset() const { return _fileOffset; }
  uint32_t extent() const { return _extent; }
  static uint32_t _sizeof() { return 12; }
private:
  int64_t	_fileOffset;
  uint32_t	_extent;
};
#pragma pack(pop)

/** @class ProxyV1

  
*/

class ConfigV1;
#pragma pack(push,4)

class ProxyV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SmlDataProxy /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ProxyV1(int64_t arg__fileOffset, const Pds::TypeId& arg__type, uint32_t arg__extent)
    : _fileOffset(arg__fileOffset), _type(arg__type), _extent(arg__extent)
  {
  }
  ProxyV1() {}
  ProxyV1(const ProxyV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ProxyV1& operator=(const ProxyV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  int64_t fileOffset() const { return _fileOffset; }
  const Pds::TypeId& type() const { return _type; }
  uint32_t extent() const { return _extent; }
  static uint32_t _sizeof() { return (((((8+(Pds::TypeId::_sizeof()))+4)+4)-1)/4)*4; }
private:
  int64_t	_fileOffset;
  Pds::TypeId	_type;
  uint32_t	_extent;
};
#pragma pack(pop)
} // namespace SmlData
} // namespace Pds
#endif // PDS_SMLDATA_DDL_H
