#ifndef PDS_STREAK_DDL_H
#define PDS_STREAK_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Streak {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_StreakConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Row_Pixels = 1024 };
  enum { Column_Pixels = 1344 };
  enum { NumCalibConstants = 3 };
  enum DeviceMode {
    Focus = 0,
    Operate = 1,
  };
  enum ShutterMode {
    Closed = 0,
    Open = 1,
  };
  enum GateMode {
    Normal = 0,
    Gate = 1,
    OpenFixed = 2,
  };
  enum TriggerMode {
    Single = 0,
    Continuous = 1,
  };
  enum CalibScale {
    Nanoseconds = 0,
    Microseconds = 1,
    Milliseconds = 2,
    Seconds = 3,
  };
  ConfigV1(uint64_t arg__timeRange, Streak::ConfigV1::DeviceMode arg__mode, Streak::ConfigV1::GateMode arg__gate, uint32_t arg__gain, Streak::ConfigV1::ShutterMode arg__shutter, Streak::ConfigV1::TriggerMode arg__triggerMode, uint32_t arg__focusTimeOver, double arg__exposureTime, Streak::ConfigV1::CalibScale arg__calibScale, const double* arg__calib)
    : _timeRange(arg__timeRange), _mode(arg__mode), _gate(arg__gate), _gain(arg__gain), _shutter(arg__shutter), _triggerMode(arg__triggerMode), _focusTimeOver(arg__focusTimeOver), _exposureTime(arg__exposureTime), _calibScale(arg__calibScale)
  {
    if (arg__calib) std::copy(arg__calib, arg__calib+(3), &_calib[0]);
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** The time range of the camera (in ps). */
  uint64_t timeRange() const { return _timeRange; }
  /** The trigger mode of the camera. */
  Streak::ConfigV1::DeviceMode mode() const { return Streak::ConfigV1::DeviceMode(_mode); }
  /** The gate mode of the camera. */
  Streak::ConfigV1::GateMode gate() const { return Streak::ConfigV1::GateMode(_gate); }
  /** Camera II-gain value. */
  uint32_t gain() const { return _gain; }
  /** The shutter configuration of the camera. */
  Streak::ConfigV1::ShutterMode shutter() const { return Streak::ConfigV1::ShutterMode(_shutter); }
  /** The trigger mode of the camera. */
  Streak::ConfigV1::TriggerMode triggerMode() const { return Streak::ConfigV1::TriggerMode(_triggerMode); }
  /** The focus mode time out in minutes. */
  uint32_t focusTimeOver() const { return _focusTimeOver; }
  /** The configured exposure time of the camera in seconds. */
  double exposureTime() const { return _exposureTime; }
  /** Time calibration scale (ns, us, ms, or s). */
  Streak::ConfigV1::CalibScale calibScale() const { return Streak::ConfigV1::CalibScale(_calibScale); }
  /** Time calibration constants (c0 + c1 * n + c2 * n * n).

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> calib(const boost::shared_ptr<T>& owner) const { 
    const double* data = &_calib[0];
    return make_ndarray(boost::shared_ptr<const double>(owner, data), NumCalibConstants);
  }
  /** Time calibration constants (c0 + c1 * n + c2 * n * n).

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> calib() const { return make_ndarray(&_calib[0], NumCalibConstants); }
  /** Factor for converting the time calibration value to seconds. */
  double calibScaleFactor() const;
  /** The X-axis pixel to time mapping in units set in calibScale. */
  ndarray<const double, 1> calibTimes() const;
  /** The X-axis pixel to time mapping in seconds. */
  ndarray<const double, 1> calibTimesInSeconds() const;
  static uint32_t _sizeof() { return ((((44+(8*(NumCalibConstants)))+4)-1)/4)*4; }
private:
  uint64_t	_timeRange;	/**< The time range of the camera (in ps). */
  uint32_t	_mode;	/**< The trigger mode of the camera. */
  uint32_t	_gate;	/**< The gate mode of the camera. */
  uint32_t	_gain;	/**< Camera II-gain value. */
  uint32_t	_shutter;	/**< The shutter configuration of the camera. */
  uint32_t	_triggerMode;	/**< The trigger mode of the camera. */
  uint32_t	_focusTimeOver;	/**< The focus mode time out in minutes. */
  double	_exposureTime;	/**< The configured exposure time of the camera in seconds. */
  uint32_t	_calibScale;	/**< Time calibration scale (ns, us, ms, or s). */
  double	_calib[NumCalibConstants];	/**< Time calibration constants (c0 + c1 * n + c2 * n * n). */
};
std::ostream& operator<<(std::ostream& str, Streak::ConfigV1::DeviceMode enval);
std::ostream& operator<<(std::ostream& str, Streak::ConfigV1::ShutterMode enval);
std::ostream& operator<<(std::ostream& str, Streak::ConfigV1::GateMode enval);
std::ostream& operator<<(std::ostream& str, Streak::ConfigV1::TriggerMode enval);
std::ostream& operator<<(std::ostream& str, Streak::ConfigV1::CalibScale enval);
#pragma pack(pop)
} // namespace Streak
} // namespace Pds
#endif // PDS_STREAK_DDL_H
