#ifndef PDS_EPIX_DDL_H
#define PDS_EPIX_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/psddl/genericpgp.ddl.h"
namespace Pds {
namespace Epix {

/** @class AsicConfigV1

  
*/

#pragma pack(push,4)

class AsicConfigV1 {
public:
  AsicConfigV1(uint8_t arg__monostPulser, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint16_t arg__pulser, uint8_t arg__pbit, uint8_t arg__atest, uint8_t arg__test, uint8_t arg__sabTest, uint8_t arg__hrTest, uint8_t arg__digMon1, uint8_t arg__digMon2, uint8_t arg__pulserDac, uint8_t arg__Dm1En, uint8_t arg__Dm2En, uint8_t arg__slvdSBit, uint8_t arg__VRefDac, uint8_t arg__TpsTComp, uint8_t arg__TpsMux, uint8_t arg__RoMonost, uint8_t arg__TpsGr, uint8_t arg__S2dGr, uint8_t arg__PpOcbS2d, uint8_t arg__Ocb, uint8_t arg__Monost, uint8_t arg__FastppEnable, uint8_t arg__Preamp, uint8_t arg__PixelCb, uint8_t arg__S2dTComp, uint8_t arg__FilterDac, uint8_t arg__TC, uint8_t arg__S2d, uint8_t arg__S2dDacBias, uint8_t arg__TpsTcDac, uint8_t arg__TpsDac, uint8_t arg__S2dTcDac, uint8_t arg__S2dDac, uint8_t arg__TestBe, uint8_t arg__IsEn, uint8_t arg__DelExec, uint8_t arg__DelCckReg, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColStartAddr, uint8_t arg__ColStopAddr, uint16_t arg__chipID);
  AsicConfigV1() {}
  AsicConfigV1(const AsicConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  AsicConfigV1& operator=(const AsicConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t monostPulser() const { return uint8_t(this->_reg1 & 0x7); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint16_t pulser() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pbit() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t atest() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t test() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t sabTest() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t hrTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t digMon1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digMon2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t pulserDac() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t Dm1En() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t Dm2En() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t slvdSBit() const { return uint8_t((this->_reg6>>4) & 0x1); }
  uint8_t VRefDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t TpsTComp() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t TpsMux() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t RoMonost() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t TpsGr() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t S2dGr() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t PpOcbS2d() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t Ocb() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t Monost() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t FastppEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t Preamp() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t PixelCb() const { return uint8_t((this->_reg11>>4) & 0x7); }
  uint8_t S2dTComp() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t FilterDac() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t TC() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t S2d() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t S2dDacBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t TpsTcDac() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t TpsDac() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t S2dTcDac() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t S2dDac() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t TestBe() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t IsEn() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t DelExec() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t DelCckReg() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
};
#pragma pack(pop)

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ConfigV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__lastRowExclusions, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, const Epix::AsicConfigV1* arg__asics, const uint32_t* arg__asicPixelTestArray, const uint32_t* arg__asicPixelMaskArray);
  ConfigV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow)
    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t lastRowExclusions() const { return _lastRowExclusions; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  /** generally 2 x 2 */
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  /** for epix100  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix100 96*4 */
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  const Epix::AsicConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=112;
  const Epix::AsicConfigV1* memptr = (const Epix::AsicConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::AsicConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 3> asicPixelTestArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 3> asicPixelTestArray() const { ptrdiff_t offset=112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 3> asicPixelMaskArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(4*(((this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic()))*( (this->numberOfPixelsPerAsicRow()+31)/32)));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 3> asicPixelMaskArray() const { ptrdiff_t offset=(112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(4*(((this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic()))*( (this->numberOfPixelsPerAsicRow()+31)/32)));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32); }
  /** Number of rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic() - this->lastRowExclusions(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((112+(Epix::AsicConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(4*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic())*( (this->numberOfPixelsPerAsicRow()+31)/32)))+(4*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic())*( (this->numberOfPixelsPerAsicRow()+31)/32)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_lastRowExclusions;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;	/**< generally 2 x 2 */
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix100  352 */
  uint32_t	_baseClockFrequency;	/**< for epix100 96*4 */
  uint32_t	_asicMask;
  //Epix::AsicConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint32_t	_asicPixelTestArray[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()][ this->numberOfRowsPerAsic()][ (this->numberOfPixelsPerAsicRow()+31)/32];
  //uint32_t	_asicPixelMaskArray[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()][ this->numberOfRowsPerAsic()][ (this->numberOfPixelsPerAsicRow()+31)/32];
};
#pragma pack(pop)

/** @class Asic10kConfigV1

  
*/

#pragma pack(push,4)

class Asic10kConfigV1 {
public:
  Asic10kConfigV1(uint8_t arg__CompTH_DAC, uint8_t arg__CompEn_0, uint8_t arg__PulserSync, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint8_t arg__dummyG, uint8_t arg__dummyGA, uint16_t arg__dummyUpper12bits, uint16_t arg__pulser, uint8_t arg__pbit, uint8_t arg__atest, uint8_t arg__test, uint8_t arg__sabTest, uint8_t arg__hrTest, uint8_t arg__PulserR, uint8_t arg__digMon1, uint8_t arg__digMon2, uint8_t arg__pulserDac, uint8_t arg__monostPulser, uint8_t arg__CompEn_1, uint8_t arg__CompEn_2, uint8_t arg__Dm1En, uint8_t arg__Dm2En, uint8_t arg__emph_bd, uint8_t arg__emph_bc, uint8_t arg__VRefDac, uint8_t arg__VrefLow, uint8_t arg__TpsTComp, uint8_t arg__TpsMux, uint8_t arg__RoMonost, uint8_t arg__TpsGr, uint8_t arg__S2dGr, uint8_t arg__PpOcbS2d, uint8_t arg__Ocb, uint8_t arg__Monost, uint8_t arg__FastppEnable, uint8_t arg__Preamp, uint8_t arg__PixelCb, uint8_t arg__Vld1_b, uint8_t arg__S2dTComp, uint8_t arg__FilterDac, uint8_t arg__testVDTransmitter, uint8_t arg__TC, uint8_t arg__S2d, uint8_t arg__S2dDacBias, uint8_t arg__TpsTcDac, uint8_t arg__TpsDac, uint8_t arg__S2dTcDac, uint8_t arg__S2dDac, uint8_t arg__TestBe, uint8_t arg__IsEn, uint8_t arg__DelExec, uint8_t arg__DelCckReg, uint8_t arg__RO_rst_en, uint8_t arg__slvdSBit, uint8_t arg__FELmode, uint8_t arg__CompEnOn, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColStartAddr, uint8_t arg__ColStopAddr, uint16_t arg__chipID);
  Asic10kConfigV1() {}
  Asic10kConfigV1(const Asic10kConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Asic10kConfigV1& operator=(const Asic10kConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t CompTH_DAC() const { return uint8_t(this->_reg1 & 0x3f); }
  uint8_t CompEn_0() const { return uint8_t((this->_reg1>>6) & 0x1); }
  uint8_t PulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint8_t dummyG() const { return uint8_t((this->_reg2>>2) & 0x1); }
  uint8_t dummyGA() const { return uint8_t((this->_reg2>>3) & 0x1); }
  uint16_t dummyUpper12bits() const { return uint16_t((this->_reg2>>4) & 0xfff); }
  uint16_t pulser() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pbit() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t atest() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t test() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t sabTest() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t hrTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t pulserR() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t digMon1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digMon2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t pulserDac() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t monostPulser() const { return uint8_t((this->_reg5>>3) & 0x7); }
  uint8_t CompEn_1() const { return uint8_t((this->_reg5>>6) & 0x1); }
  uint8_t CompEn_2() const { return uint8_t((this->_reg5>>7) & 0x1); }
  uint8_t Dm1En() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t Dm2En() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t emph_bd() const { return uint8_t((this->_reg6>>2) & 0x7); }
  uint8_t emph_bc() const { return uint8_t((this->_reg6>>5) & 0x7); }
  uint8_t VRefDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t vrefLow() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t TpsTComp() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t TpsMux() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t RoMonost() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t TpsGr() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t S2dGr() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t PpOcbS2d() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t Ocb() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t Monost() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t FastppEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t Preamp() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t PixelCb() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t Vld1_b() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t S2dTComp() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t FilterDac() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t testVDTransmitter() const { return uint8_t((this->_reg12>>7) & 0x1); }
  uint8_t TC() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t S2d() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t S2dDacBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t TpsTcDac() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t TpsDac() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t S2dTcDac() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t S2dDac() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t TestBe() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t IsEn() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t DelExec() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t DelCckReg() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t RO_rst_en() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint8_t slvdSBit() const { return uint8_t((this->_reg16>>5) & 0x1); }
  uint8_t FELmode() const { return uint8_t((this->_reg16>>6) & 0x1); }
  uint8_t CompEnOn() const { return uint8_t((this->_reg16>>7) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
};
#pragma pack(pop)

/** @class Config10KV1

  
*/

#pragma pack(push,4)

class Config10KV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  Config10KV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__DoutPipelineDelay, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__lastRowExclusions, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic10kConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray);
  Config10KV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t lastRowExclusions)
    : _lastRowExclusions(lastRowExclusions), _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow)
  {
  }
  Config10KV1() {}
  Config10KV1(const Config10KV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10KV1& operator=(const Config10KV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  /** new */
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  /** new */
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  /** new */
  uint32_t DoutPipelineDelay() const { return _DoutPipelineDelay; }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  /** new */
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  /** new */
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t lastRowExclusions() const { return _lastRowExclusions; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  /** for epix10k  176 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix10k 48*4 */
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic10kConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=136;
  const Epix::Asic10kConfigV1* memptr = (const Epix::Asic10kConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic10kConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=136+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()));
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> asicPixelConfigArray() const { ptrdiff_t offset=136+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow())); }
  /** Number of rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic() - this->lastRowExclusions(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return (((((136+(Epix::Asic10kConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic())*( (this->numberOfPixelsPerAsicRow()))))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_DoutPipelineDelay;	/**< new */
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_lastRowExclusions;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix10k  176 */
  uint32_t	_baseClockFrequency;	/**< for epix10k 48*4 */
  uint32_t	_asicMask;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic10kConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()][ this->numberOfRowsPerAsic()][ (this->numberOfPixelsPerAsicRow())];
};
#pragma pack(pop)

/** @class Asic100aConfigV1

  
*/

#pragma pack(push,4)

class Asic100aConfigV1 {
public:
  Asic100aConfigV1(uint8_t arg__pulserVsPixelOnDelay, uint8_t arg__pulserSync, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint16_t arg__testPulserLevel, uint8_t arg__pulserCounterDirection, uint8_t arg__automaticTestModeEnable, uint8_t arg__testMode, uint8_t arg__testModeWithDarkFrame, uint8_t arg__highResolutionModeTest, uint8_t arg__pulserReset, uint8_t arg__digitalMonitorMux1, uint8_t arg__digitalMonitorMux2, uint8_t arg__testPulserCurrent, uint8_t arg__testPointSystemOutputDynamicRange, uint8_t arg__digitalMonitor1Enable, uint8_t arg__digitalMonitor2Enable, uint8_t arg__LVDS_ImpedenceMatchingEnable, uint8_t arg__VRefBaseLineDac, uint8_t arg__extraRowsLowReferenceValue, uint8_t arg__testPointSystemTemperatureCompensationEnable, uint8_t arg__testPointSytemInputSelect, uint8_t arg__programmableReadoutDelay, uint8_t arg__outputDriverOutputDynamicRange0, uint8_t arg__outputDriverOutputDynamicRange1, uint8_t arg__balconyEnable, uint8_t arg__balconyDriverCurrent, uint8_t arg__fastPowerPulsingSpeed, uint8_t arg__fastPowerPulsingEnable, uint8_t arg__preamplifierCurrent, uint8_t arg__pixelOutputBufferCurrent, uint8_t arg__pixelBufferAndPreamplifierDrivingCapabilities, uint8_t arg__outputDriverTemperatureCompensationEnable, uint8_t arg__pixelFilterLevel, uint8_t arg__bandGapReferenceTemperatureCompensationBits, uint8_t arg__outputDriverDrivingCapabilitiesAndStability, uint8_t arg__outputDriverDacReferenceBias, uint8_t arg__testPointSystemTemperatureCompensationGain, uint8_t arg__testPointSystemInputCommonMode, uint8_t arg__outputDriverTemperatureCompensationGain0, uint8_t arg__outputDriverInputCommonMode0, uint8_t arg__testBackEnd, uint8_t arg__interleavedReadOutEnable, uint8_t arg_EXEC_DelayEnable, uint8_t arg__CCK_RegDelayEnable, uint8_t arg__syncPinEnable, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColumnStartAddr, uint8_t arg__ColumnStopAddr, uint16_t arg__chipID, uint8_t arg__outputDriverOutputDynamicRange2, uint8_t arg__outputDriverOutputDynamicRange3, uint8_t arg__outputDriverTemperatureCompensationGain1, uint8_t arg__outputDriverInputCommonMode1, uint8_t arg__outputDriverTemperatureCompensationGain2, uint8_t arg__outputDriverInputCommonMode2, uint8_t arg__outputDriverTemperatureCompensationGain3, uint8_t arg__outputDriverInputCommonMode3);
  Asic100aConfigV1() {}
  Asic100aConfigV1(const Asic100aConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Asic100aConfigV1& operator=(const Asic100aConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t pulserVsPixelOnDelay() const { return uint8_t(this->_reg1 & 0x7); }
  uint8_t pulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint16_t testPulserLevel() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pulserCounterDirection() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t automaticTestModeEnable() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t testMode() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t testModeWithDarkFrame() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t highResolutionModeTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t pulserReset() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t digitalMonitorMux1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digitalMonitorMux2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t testPulserCurrent() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t testPointSystemOutputDynamicRange() const { return uint8_t((this->_reg5>>4) & 0xf); }
  uint8_t digitalMonitor1Enable() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t digitalMonitor2Enable() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t LVDS_ImpedenceMatchingEnable() const { return uint8_t((this->_reg6>>4) & 0x1); }
  uint8_t VRefBaselineDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t extraRowsLowReferenceValue() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t testPointSystemTemperatureCompensationEnable() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t testPointSytemInputSelect() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t programmableReadoutDelay() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t outputDriverOutputDynamicRange0() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t outputDriverOutputDynamicRange1() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t balconyEnable() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t balconyDriverCurrent() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t fastPowerPulsingSpeed() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t fastPowerPulsingEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t preamplifierCurrent() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t pixelOutputBufferCurrent() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t pixelBufferAndPreamplifierDrivingCapabilities() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t outputDriverTemperatureCompensationEnable() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t pixelFilterLevel() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t bandGapReferenceTemperatureCompensationBits() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t outputDriverDrivingCapabilitiesAndStability() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t outputDriverDacReferenceBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t testPointSystemTemperatureCompensationGain() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t testPointSystemInputCommonMode() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain0() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t outputDriverInputCommonMode0() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t testBackEnd() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t interleavedReadOutEnable() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t EXEC_DelayEnable() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t CCK_RegDelayEnable() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t syncPinEnable() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColumnStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColumnStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  uint8_t outputDriverOutputDynamicRange2() const { return uint8_t(this->_reg22 & 0xf); }
  uint8_t outputDriverOutputDynamicRange3() const { return uint8_t((this->_reg22>>4) & 0xf); }
  uint8_t outputDriverTemperatureCompensationGain1() const { return uint8_t(this->_reg23 & 0x3); }
  uint8_t outputDriverInputCommonMode1() const { return uint8_t((this->_reg23>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain2() const { return uint8_t(this->_reg24 & 0x3); }
  uint8_t outputDriverInputCommonMode2() const { return uint8_t((this->_reg24>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain3() const { return uint8_t(this->_reg25 & 0x3); }
  uint8_t outputDriverInputCommonMode3() const { return uint8_t((this->_reg25>>2) & 0x3f); }
  static uint32_t _sizeof() { return 100; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
  uint32_t	_reg22;
  uint32_t	_reg23;
  uint32_t	_reg24;
  uint32_t	_reg25;
};
#pragma pack(pop)

/** @class Config100aV1

  
*/

#pragma pack(push,4)

class Config100aV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix100aConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  Config100aV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic100aConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
  Config100aV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
  {
  }
  Config100aV1() {}
  Config100aV1(const Config100aV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config100aV1& operator=(const Config100aV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix100a  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix100a 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic100aConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=144;
  const Epix::Asic100aConfigV1* memptr = (const Epix::Asic100aConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic100aConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
  /** Calibration row config map is one row for every two calib rows

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
  }
  /** Calibration row config map is one row for every two calib rows

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((144+(Epix::Asic100aConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix100a  352 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix100a 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic100aConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class Config100aV2

  
*/

#pragma pack(push,4)

class Config100aV2 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix100aConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  Config100aV2(uint32_t arg__version, uint32_t arg__usePgpEvr, uint32_t arg__evrRunCode, uint32_t arg__evrDaqCode, uint32_t arg__evrRunTrigDelay, uint32_t arg__epixRunTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__adcPipelineDelay0, uint32_t arg__adcPipelineDelay1, uint32_t arg__adcPipelineDelay2, uint32_t arg__adcPipelineDelay3, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic100aConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
  Config100aV2(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
  {
  }
  Config100aV2() {}
  Config100aV2(const Config100aV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config100aV2& operator=(const Config100aV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t usePgpEvr() const { return _usePgpEvr; }
  uint32_t evrRunCode() const { return _evrRunCode; }
  uint32_t evrDaqCode() const { return _evrDaqCode; }
  uint32_t evrRunTrigDelay() const { return _evrRunTrigDelay; }
  uint32_t epixRunTrigDelay() const { return _epixRunTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t adcPipelineDelay0() const { return _adcPipelineDelay0; }
  uint32_t adcPipelineDelay1() const { return _adcPipelineDelay1; }
  uint32_t adcPipelineDelay2() const { return _adcPipelineDelay2; }
  uint32_t adcPipelineDelay3() const { return _adcPipelineDelay3; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix100a  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix100a 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic100aConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=188;
  const Epix::Asic100aConfigV1* memptr = (const Epix::Asic100aConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic100aConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
  /** Calibration row config map is one row for every two calib rows

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
  }
  /** Calibration row config map is one row for every two calib rows

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((188+(Epix::Asic100aConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_usePgpEvr;
  uint32_t	_evrRunCode;
  uint32_t	_evrDaqCode;
  uint32_t	_evrRunTrigDelay;
  uint32_t	_epixRunTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_adcPipelineDelay0;
  uint32_t	_adcPipelineDelay1;
  uint32_t	_adcPipelineDelay2;
  uint32_t	_adcPipelineDelay3;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix100a  352 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix100a 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic100aConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class AsicSConfigV1

  
*/

#pragma pack(push,4)

class AsicSConfigV1 {
public:
  AsicSConfigV1(uint8_t arg__pulserSync, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint16_t arg__testPulserLevel, uint8_t arg__pulserCounterDirection, uint8_t arg__automaticTestModeEnable, uint8_t arg__testMode, uint8_t arg__testModeWithDarkFrame, uint8_t arg__highResolutionModeTest, uint8_t arg__pulserReset, uint8_t arg__digitalMonitorMux1, uint8_t arg__digitalMonitorMux2, uint8_t arg__testPulserCurrent, uint8_t arg__pulserVsPixelOnDelay, uint8_t arg__digitalMonitor1Enable, uint8_t arg__digitalMonitor2Enable, uint8_t arg__inputLeakageCompensation, uint8_t arg__inputLeakageCompensationEnable, uint8_t arg__VRefBaseLineDac, uint8_t arg__extraRowsLowReferenceValue, uint8_t arg__testPointSystemTemperatureCompensationEnable, uint8_t arg__testPointSytemInputSelect, uint8_t arg__programmableReadoutDelay, uint8_t arg__testPointSystemOutputDynamicRange, uint8_t arg__outputDriverOutputDynamicRange, uint8_t arg__balconyEnable, uint8_t arg__balconyDriverCurrent, uint8_t arg__fastPowerPulsingSpeed, uint8_t arg__fastPowerPulsingEnable, uint8_t arg__preamplifierCurrent, uint8_t arg__pixelOutputBufferCurrent, uint8_t arg__pixelBufferAndPreamplifierDrivingCapabilities, uint8_t arg__outputDriverTemperatureCompensationEnable, uint8_t arg__pixelFilterLevel, uint8_t arg__bandGapReferenceTemperatureCompensationBits, uint8_t arg__outputDriverDrivingCapabilitiesAndStability, uint8_t arg__outputDriverDacReferenceBias, uint8_t arg__testPointSystemTemperatureCompensationGain, uint8_t arg__testPointSystemInputCommonMode, uint8_t arg__outputDriverTemperatureCompensationGain, uint8_t arg__outputDriverInputCommonMode, uint8_t arg__testBackEnd, uint8_t arg__interleavedReadOutEnable, uint8_t arg_EXEC_DelayEnable, uint8_t arg__CCK_RegDelayEnable, uint8_t arg__syncPinEnable, uint8_t arg__LVDS_ImpedenceMatchingEnable, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColumnStartAddr, uint8_t arg__ColumnStopAddr, uint16_t arg__chipID);
  AsicSConfigV1() {}
  AsicSConfigV1(const AsicSConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  AsicSConfigV1& operator=(const AsicSConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t pulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint16_t testPulserLevel() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pulserCounterDirection() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t automaticTestModeEnable() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t testMode() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t testModeWithDarkFrame() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t highResolutionModeTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t pulserReset() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t digitalMonitorMux1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digitalMonitorMux2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t testPulserCurrent() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t pulserVsPixelOnDelay() const { return uint8_t((this->_reg5>>3) & 0x7); }
  uint8_t digitalMonitor1Enable() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t digitalMonitor2Enable() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t inputLeakageCompensation() const { return uint8_t((this->_reg6>>2) & 0x3); }
  uint8_t inputLeakageCompensationEnable() const { return uint8_t((this->_reg6>>4) & 0x1); }
  uint8_t VRefBaselineDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t extraRowsLowReferenceValue() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t testPointSystemTemperatureCompensationEnable() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t testPointSytemInputSelect() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t programmableReadoutDelay() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t testPointSystemOutputDynamicRange() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t outputDriverOutputDynamicRange() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t balconyEnable() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t balconyDriverCurrent() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t fastPowerPulsingSpeed() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t fastPowerPulsingEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t preamplifierCurrent() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t pixelOutputBufferCurrent() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t pixelBufferAndPreamplifierDrivingCapabilities() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t outputDriverTemperatureCompensationEnable() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t pixelFilterLevel() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t bandGapReferenceTemperatureCompensationBits() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t outputDriverDrivingCapabilitiesAndStability() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t outputDriverDacReferenceBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t testPointSystemTemperatureCompensationGain() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t testPointSystemInputCommonMode() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain0() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t outputDriverInputCommonMode0() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t testBackEnd() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t interleavedReadOutEnable() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t EXEC_DelayEnable() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t CCK_RegDelayEnable() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t syncPinEnable() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint8_t LVDS_ImpedenceMatchingEnable() const { return uint8_t((this->_reg16>>5) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColumnStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColumnStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
};
#pragma pack(pop)

/** @class ConfigSV1

  
*/

#pragma pack(push,4)

class ConfigSV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixSConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ConfigSV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::AsicSConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
  ConfigSV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
  {
  }
  ConfigSV1() {}
  ConfigSV1(const ConfigSV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigSV1& operator=(const ConfigSV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epixS  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epixS 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::AsicSConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=152;
  const Epix::AsicSConfigV1* memptr = (const Epix::AsicSConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::AsicSConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
  /** Calibration row config map is one row for every two calib rows

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
  }
  /** Calibration row config map is one row for every two calib rows

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((152+(Epix::AsicSConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epixS  352 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epixS 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::AsicSConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class Asic10kaConfigV1

  
*/

#pragma pack(push,4)

class Asic10kaConfigV1 {
public:
  Asic10kaConfigV1(uint8_t arg__CompTH_DAC, uint8_t arg__CompEn_lowBit, uint8_t arg__PulserSync, uint8_t arg__pixelDummy, uint16_t arg__Pulser, uint8_t arg__Pbit, uint8_t arg__atest, uint8_t arg__test, uint8_t arg__Sab_test, uint8_t arg__Hrtest, uint8_t arg__PulserR, uint8_t arg__DM1, uint8_t arg__DM2, uint8_t arg__Pulser_DAC, uint8_t arg__Monost_Pulser, uint8_t arg__CompEn_topTwoBits, uint8_t arg__DM1en, uint8_t arg__DM2en, uint8_t arg__emph_bd, uint8_t arg__emph_bc, uint8_t arg__VREF_DAC, uint8_t arg__VrefLow, uint8_t arg__TPS_tcomp, uint8_t arg__TPS_MUX, uint8_t arg__RO_Monost, uint8_t arg__TPS_GR, uint8_t arg__S2D0_GR, uint8_t arg__PP_OCB_S2D, uint8_t arg__OCB, uint8_t arg__Monost, uint8_t arg__fastPP_enable, uint8_t arg__Preamp, uint8_t arg__Pixel_CB, uint8_t arg__Vld1_b, uint8_t arg__S2D_tcomp, uint8_t arg__Filter_DAC, uint8_t arg__testLVDTransmitter, uint8_t arg__tc, uint8_t arg__S2D, uint8_t arg__S2D_DAC_Bias, uint8_t arg__TPS_tcDAC, uint8_t arg__TPS_DAC, uint8_t arg__S2D0_tcDAC, uint8_t arg__S2D0_DAC, uint8_t arg__testBE, uint8_t arg__is_en, uint8_t arg__DelEXEC, uint8_t arg__DelCCKreg, uint8_t arg__RO_rst_en, uint8_t arg__SLVDSbit, uint8_t arg__FELmode, uint8_t arg__CompEnOn, uint16_t arg__RowStart, uint16_t arg__RowStop, uint8_t arg__ColumnStart, uint8_t arg__ColumnStop, uint16_t arg__chipID, uint8_t arg__S2D1_GR, uint8_t arg__S2D2_GR, uint8_t arg__S2D3_GR, uint8_t arg__trbit, uint8_t arg__S2D1_tcDAC, uint8_t arg__S2D1_DAC, uint8_t arg__S2D2_tcDAC, uint8_t arg__S2D2_DAC, uint8_t arg__S2D3_tcDAC, uint8_t arg__S2D3_DAC);
  Asic10kaConfigV1() {}
  Asic10kaConfigV1(const Asic10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Asic10kaConfigV1& operator=(const Asic10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t CompTH_DAC() const { return uint8_t(this->_reg1 & 0x3f); }
  uint8_t CompEn_lowBit() const { return uint8_t((this->_reg1>>6) & 0x1); }
  uint8_t PulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t pixelDummy() const { return uint8_t(this->_reg2 & 0xff); }
  uint16_t Pulser() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t Pbit() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t atest() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t test() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t Sab_test() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t Hrtest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t PulserR() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t DM1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t DM2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t Pulser_DAC() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t Monost_Pulser() const { return uint8_t((this->_reg5>>3) & 0x7); }
  uint8_t CompEn_topTwoBits() const { return uint8_t((this->_reg5>>6) & 0x3); }
  uint8_t DM1en() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t DM2en() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t emph_bd() const { return uint8_t((this->_reg6>>2) & 0x7); }
  uint8_t emph_bc() const { return uint8_t((this->_reg6>>5) & 0x7); }
  uint8_t VREF_DAC() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t VrefLow() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t TPS_tcomp() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t TPS_MUX() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t RO_Monost() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t TPS_GR() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t S2D0_GR() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t PP_OCB_S2D() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t OCB() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t Monost() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t fastPP_enable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t Preamp() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t PixelCB() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t Vld1_b() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t S2D_tcomp() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t Filter_DAC() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t testLVDTransmitter() const { return uint8_t((this->_reg12>>7) & 0x1); }
  uint8_t tc() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t S2D() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t S2D_DAC_Bias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t TPS_tcDAC() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t TPS_DAC() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t S2D0_tcDAC() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t S2D0_DAC() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t testBE() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t is_en() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t DelEXEC() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t DelCCKreg() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t RO_rst_en() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint8_t SLVDSbit() const { return uint8_t((this->_reg16>>5) & 0x1); }
  uint8_t FELmode() const { return uint8_t((this->_reg16>>6) & 0x1); }
  uint8_t CompEnOn() const { return uint8_t((this->_reg16>>7) & 0x1); }
  uint16_t RowStart() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStop() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColumnStart() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColumnStop() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  uint8_t S2D1_GR() const { return uint8_t(this->_reg22 & 0xf); }
  uint8_t S2D2_GR() const { return uint8_t((this->_reg22>>4) & 0xf); }
  uint8_t S2D3_GR() const { return uint8_t(this->_reg23 & 0xf); }
  uint8_t trbit() const { return uint8_t((this->_reg23>>4) & 0x1); }
  uint8_t S2D1_tcDAC() const { return uint8_t(this->_reg24 & 0x3); }
  uint8_t S2D1_DAC() const { return uint8_t((this->_reg24>>2) & 0x3f); }
  uint8_t S2D2_tcDAC() const { return uint8_t(this->_reg25 & 0x3); }
  uint8_t S2D2_DAC() const { return uint8_t((this->_reg25>>2) & 0x3f); }
  uint8_t S2D3_tcDAC() const { return uint8_t(this->_reg26 & 0x3); }
  uint8_t S2D3_DAC() const { return uint8_t((this->_reg26>>2) & 0x3f); }
  static uint32_t _sizeof() { return 104; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
  uint32_t	_reg22;
  uint32_t	_reg23;
  uint32_t	_reg24;
  uint32_t	_reg25;
  uint32_t	_reg26;
};
#pragma pack(pop)

/** @class Config10kaV1

  
*/

#pragma pack(push,4)

class Config10kaV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kaConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  Config10kaV1(uint32_t arg__version, uint32_t arg__usePgpEvr, uint32_t arg__evrRunCode, uint32_t arg__evrDaqCode, uint32_t arg__evrRunTrigDelay, uint32_t arg__epixRunTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__adcPipelineDelay0, uint32_t arg__adcPipelineDelay1, uint32_t arg__adcPipelineDelay2, uint32_t arg__adcPipelineDelay3, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic10kaConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
  Config10kaV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
  {
  }
  Config10kaV1() {}
  Config10kaV1(const Config10kaV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10kaV1& operator=(const Config10kaV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t usePgpEvr() const { return _usePgpEvr; }
  uint32_t evrRunCode() const { return _evrRunCode; }
  uint32_t evrDaqCode() const { return _evrDaqCode; }
  uint32_t evrRunTrigDelay() const { return _evrRunTrigDelay; }
  uint32_t epixRunTrigDelay() const { return _epixRunTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t adcPipelineDelay0() const { return _adcPipelineDelay0; }
  uint32_t adcPipelineDelay1() const { return _adcPipelineDelay1; }
  uint32_t adcPipelineDelay2() const { return _adcPipelineDelay2; }
  uint32_t adcPipelineDelay3() const { return _adcPipelineDelay3; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix10ka  176 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix10ka 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic10kaConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=188;
  const Epix::Asic10kaConfigV1* memptr = (const Epix::Asic10kaConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic10kaConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
  /** Calibration row config map is one row for every two calib rows

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
  }
  /** Calibration row config map is one row for every two calib rows

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((188+(Epix::Asic10kaConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_usePgpEvr;
  uint32_t	_evrRunCode;
  uint32_t	_evrDaqCode;
  uint32_t	_evrRunTrigDelay;
  uint32_t	_epixRunTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_adcPipelineDelay0;
  uint32_t	_adcPipelineDelay1;
  uint32_t	_adcPipelineDelay2;
  uint32_t	_adcPipelineDelay3;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix10ka  176 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix10ka 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic10kaConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class Config10kaV2

  
*/

#pragma pack(push,4)

class Config10kaV2 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kaConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { FirmwareHashMax = 64 };
  enum { FirmwareDescMax = 256 };
  Config10kaV2(uint32_t arg__version, uint32_t arg__usePgpEvr, uint32_t arg__evrRunCode, uint32_t arg__evrDaqCode, uint32_t arg__evrRunTrigDelay, uint32_t arg__epixRunTrigDelay, uint32_t arg__epixDaqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__adcPipelineDelay0, uint32_t arg__adcPipelineDelay1, uint32_t arg__adcPipelineDelay2, uint32_t arg__adcPipelineDelay3, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint32_t arg__ghostCorrEn, uint32_t arg__oversampleEn, uint32_t arg__oversampleSize, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const char* arg__firmwareHash, const char* arg__firmwareDesc, const Epix::Asic10kaConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
  Config10kaV2(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
  {
  }
  Config10kaV2() {}
  Config10kaV2(const Config10kaV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10kaV2& operator=(const Config10kaV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t usePgpEvr() const { return _usePgpEvr; }
  uint32_t evrRunCode() const { return _evrRunCode; }
  uint32_t evrDaqCode() const { return _evrDaqCode; }
  uint32_t evrRunTrigDelay() const { return _evrRunTrigDelay; }
  uint32_t epixRunTrigDelay() const { return _epixRunTrigDelay; }
  uint32_t epixDaqTrigDelay() const { return _epixDaqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t adcPipelineDelay0() const { return _adcPipelineDelay0; }
  uint32_t adcPipelineDelay1() const { return _adcPipelineDelay1; }
  uint32_t adcPipelineDelay2() const { return _adcPipelineDelay2; }
  uint32_t adcPipelineDelay3() const { return _adcPipelineDelay3; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix10ka  176 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix10ka 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  uint32_t ghostCorrEn() const { return _ghostCorrEn; }
  uint32_t oversampleEn() const { return _oversampleEn; }
  uint32_t oversampleSize() const { return _oversampleSize; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const char* firmwareHash() const { return _firmwareHash; }
  const char* firmwareDesc() const { return _firmwareDesc; }
  const Epix::Asic10kaConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=520;
  const Epix::Asic10kaConfigV1* memptr = (const Epix::Asic10kaConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic10kaConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=520+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=520+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
  /** Calibration row config map is one row for every two calib rows

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(520+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
  }
  /** Calibration row config map is one row for every two calib rows

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(520+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((((200+(1*(FirmwareHashMax)))+(1*(FirmwareDescMax)))+(Epix::Asic10kaConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by firmwareHash() method. */
  std::vector<int> firmwareHash_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by firmwareDesc() method. */
  std::vector<int> firmwareDesc_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_usePgpEvr;
  uint32_t	_evrRunCode;
  uint32_t	_evrDaqCode;
  uint32_t	_evrRunTrigDelay;
  uint32_t	_epixRunTrigDelay;
  uint32_t	_epixDaqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_adcPipelineDelay0;
  uint32_t	_adcPipelineDelay1;
  uint32_t	_adcPipelineDelay2;
  uint32_t	_adcPipelineDelay3;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix10ka  176 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix10ka 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_ghostCorrEn;
  uint32_t	_oversampleEn;
  uint32_t	_oversampleSize;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  char	_firmwareHash[FirmwareHashMax];
  char	_firmwareDesc[FirmwareDescMax];
  //Epix::Asic10kaConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class Elem10kaConfigV1

  
*/

#pragma pack(push,4)

class Elem10kaConfigV1 {
public:
  enum { _numberOfAsicsPerRow = 2 };
  enum { _numberOfAsicsPerColumn = 2 };
  enum { _numberOfRowsPerAsic = 176 };
  enum { _numberOfReadableRowsPerAsic = 176 };
  enum { _numberOfPixelsPerAsicRow = 192 };
  enum { _calibrationRowCountPerASIC = 2 };
  enum { _environmentalRowCountPerASIC = 1 };
  Elem10kaConfigV1(uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__asicMask, const Epix::Asic10kaConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
  Elem10kaConfigV1() {}
  Elem10kaConfigV1(const Elem10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Elem10kaConfigV1& operator=(const Elem10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Mimic previous Epix Config interfaces */
  uint32_t numberOfAsicsPerRow() const;
  uint32_t numberOfAsicsPerColumn() const;
  uint32_t numberOfRowsPerAsic() const;
  uint32_t numberOfReadableRowsPerAsic() const;
  uint32_t numberOfPixelsPerAsicRow() const;
  uint32_t calibrationRowCountPerASIC() const;
  uint32_t environmentalRowCountPerASIC() const;
  /** read-only */
  uint32_t carrierId0() const { return _carrierId0; }
  /** read-only */
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t asicMask() const { return _asicMask; }
  const Epix::Asic10kaConfigV1& asics(uint32_t i0) const { return _asics[i0]; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    const uint16_t* data = &_asicPixelConfigArray[0][0];
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), 352, 384);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> asicPixelConfigArray() const { return make_ndarray(&_asicPixelConfigArray[0][0], 352, 384); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const { 
    const uint8_t* data = &_calibPixelConfigArray[0][0];
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data), 2, 384);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 2> calibPixelConfigArray() const { return make_ndarray(&_calibPixelConfigArray[0][0], 2, 384); }
  /** Interface
Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  static uint32_t _sizeof() { return ((((((12+(Epix::Asic10kaConfigV1::_sizeof()*(4)))+(2*(352)*(384)))+(1*(2)*(384)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_carrierId0;	/**< read-only */
  uint32_t	_carrierId1;	/**< read-only */
  uint32_t	_asicMask;
  Epix::Asic10kaConfigV1	_asics[4];
  uint16_t	_asicPixelConfigArray[352][384];
  uint8_t	_calibPixelConfigArray[2][384];
};
#pragma pack(pop)

/** @class PgpEvrConfig

  
*/

#pragma pack(push,4)

class PgpEvrConfig {
public:
  PgpEvrConfig(uint16_t arg__enable, uint8_t arg__runCode, uint8_t arg__daqCode, uint32_t arg__runDelay);
  PgpEvrConfig() {}
  PgpEvrConfig(const PgpEvrConfig& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  PgpEvrConfig& operator=(const PgpEvrConfig& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint16_t enable() const { return _enable; }
  uint8_t runCode() const { return _runCode; }
  uint8_t daqCode() const { return _daqCode; }
  uint32_t runDelay() const { return _runDelay; }
  static uint32_t _sizeof() { return 8; }
private:
  uint16_t	_enable;
  uint8_t	_runCode;
  uint8_t	_daqCode;
  uint32_t	_runDelay;
};
#pragma pack(pop)

/** @class Ad9249Config

  
*/

#pragma pack(push,4)

class Ad9249Config {
public:
  Ad9249Config(uint32_t arg__chipId, uint32_t arg__devIndexMask, uint32_t arg__devIndexMaskDcoFco, uint8_t arg__extPwdnMode, uint8_t arg__intPwdnMode, uint8_t arg__chopMode, uint8_t arg__dutyCycleStab, uint8_t arg__outputInvert, uint8_t arg__outputFormat, uint32_t arg__clockDivide, uint32_t arg__userTestMode, uint32_t arg__outputTestMode, uint32_t arg__offsetAdjust, const uint32_t* arg__channelDelay, uint32_t arg__frameDelay);
  Ad9249Config() {}
  Ad9249Config(const Ad9249Config& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Ad9249Config& operator=(const Ad9249Config& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** read-only */
  uint32_t chipId() const { return _chipId; }
  uint32_t devIndexMask() const { return _devIndexMask; }
  uint32_t devIndexMaskDcoFco() const { return _devIndexMaskDcoFco; }
  uint8_t extPwdnMode() const { return uint8_t(this->ControlBits & 0x1); }
  uint8_t intPwdnMode() const { return uint8_t((this->ControlBits>>1) & 0x3); }
  uint8_t chopMode() const { return uint8_t((this->ControlBits>>3) & 0x1); }
  uint8_t dutyCycleStab() const { return uint8_t((this->ControlBits>>4) & 0x1); }
  uint8_t outputInvert() const { return uint8_t((this->ControlBits>>5) & 0x1); }
  uint8_t outputFormat() const { return uint8_t((this->ControlBits>>6) & 0x1); }
  uint32_t clockDivide() const { return _clockDivide; }
  uint32_t userTestMode() const { return _userTestMode; }
  uint32_t outputTestMode() const { return _outputTestMode; }
  uint32_t offsetAdjust() const { return _offsetAdjust; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> channelDelay(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_channelDelay[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), 8);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> channelDelay() const { return make_ndarray(&_channelDelay[0], 8); }
  uint32_t frameDelay() const { return _frameDelay; }
  static uint32_t _sizeof() { return (((((32+(4*(8)))+4)+4)-1)/4)*4; }
private:
  uint32_t	_chipId;	/**< read-only */
  uint32_t	_devIndexMask;
  uint32_t	_devIndexMaskDcoFco;
  uint32_t	ControlBits;
  uint32_t	_clockDivide;
  uint32_t	_userTestMode;
  uint32_t	_outputTestMode;
  uint32_t	_offsetAdjust;
  uint32_t	_channelDelay[8];
  uint32_t	_frameDelay;
};
#pragma pack(pop)

/** @class Quad10kaConfigV1

  
*/

#pragma pack(push,4)

class Quad10kaConfigV1 {
public:
  Quad10kaConfigV1(uint32_t arg__baseClockFrequency, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__dcdcEn, uint32_t arg__asicAnaEn, uint32_t arg__asicDigEn, uint32_t arg__ddrVttEn, uint32_t arg__trigSrcSel, uint32_t arg__vguardDac, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0Width, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint8_t arg_asicAcqForce, uint8_t arg_asicR0Force, uint8_t arg_asicPPmatForce, uint8_t arg_asicSyncForce, uint8_t arg_asicRoClkForce, uint8_t arg_asicAcqValue, uint8_t arg_asicR0Value, uint8_t arg_asicPPmatValue, uint8_t arg_asicSyncValue, uint8_t arg_asicRoClkValue, uint32_t arg__adcPipelineDelay, uint32_t arg__testData, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeTrigMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsamplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, uint32_t arg__scopeTrigDelay, const Epix::Ad9249Config* arg__adc, uint32_t arg__testChannel, uint32_t arg__testDataMask, uint32_t arg__testPattern, uint32_t arg__testSamples, uint32_t arg__testTimeout, uint32_t arg__testRequest);
  Quad10kaConfigV1() {}
  Quad10kaConfigV1(const Quad10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Quad10kaConfigV1& operator=(const Quad10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Global */
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  /** AxiVersion (RO) */
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  /** SystemRegs */
  uint32_t dcdcEn() const { return _dcdcEn; }
  uint32_t asicAnaEn() const { return _asicAnaEn; }
  uint32_t asicDigEn() const { return _asicDigEn; }
  uint32_t ddrVttEn() const { return _ddrVttEn; }
  uint32_t trigSrcSel() const { return _trigSrcSel; }
  uint32_t vguardDac() const { return _vguardDac; }
  /** AcqCore */
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint8_t asicAcqForce() const { return uint8_t(this->_asicForce & 0x1); }
  uint8_t asicR0Force() const { return uint8_t((this->_asicForce>>1) & 0x1); }
  uint8_t asicPPmatForce() const { return uint8_t((this->_asicForce>>2) & 0x1); }
  uint8_t asicSyncForce() const { return uint8_t((this->_asicForce>>3) & 0x1); }
  uint8_t asicRoClkForce() const { return uint8_t((this->_asicForce>>4) & 0x1); }
  uint8_t asicAcqValue() const { return uint8_t(this->_asicForceValue & 0x1); }
  uint8_t asicR0Value() const { return uint8_t((this->_asicForceValue>>1) & 0x1); }
  uint8_t asicPPmatValue() const { return uint8_t((this->_asicForceValue>>2) & 0x1); }
  uint8_t asicSyncValue() const { return uint8_t((this->_asicForceValue>>3) & 0x1); }
  uint8_t asicRoClkValue() const { return uint8_t((this->_asicForceValue>>4) & 0x1); }
  /** RdoutCore */
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t testData() const { return _testData; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0x1f); }
  uint8_t scopeTrigMode() const { return uint8_t((this->_Scope>>7) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsamplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x7f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>7) & 0x7f); }
  uint32_t scopeTrigDelay() const { return _scopeTrigDelay; }
  /** Ad9249ReadoutGroup [10]
Ad9249ConfigGroup [10] */
  const Epix::Ad9249Config& adc(uint32_t i0) const { return _adc[i0]; }
  /** AdcTester */
  uint32_t testChannel() const { return _testChannel; }
  uint32_t testDataMask() const { return _testDataMask; }
  uint32_t testPattern() const { return _testPattern; }
  uint32_t testSamples() const { return _testSamples; }
  uint32_t testTimeout() const { return _testTimeout; }
  uint32_t testRequest() const { return _testRequest; }
  static uint32_t _sizeof() { return ((((((((((108+(Epix::Ad9249Config::_sizeof()*(10)))+4)+4)+4)+4)+4)+4)+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by adc() method. */
  std::vector<int> adc_shape() const;
private:
  uint32_t	_baseClockFrequency;	/**< Global */
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_digitalCardId0;	/**< AxiVersion (RO) */
  uint32_t	_digitalCardId1;
  uint32_t	_dcdcEn;	/**< SystemRegs */
  uint32_t	_asicAnaEn;
  uint32_t	_asicDigEn;
  uint32_t	_ddrVttEn;
  uint32_t	_trigSrcSel;
  uint32_t	_vguardDac;
  uint32_t	_acqToAsicR0Delay;	/**< AcqCore */
  uint32_t	_asicR0Width;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_asicForce;
  uint32_t	_asicForceValue;
  uint32_t	_adcPipelineDelay;	/**< RdoutCore */
  uint32_t	_testData;
  uint32_t	_Scope;	/**< PseudoScopeCore */
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  uint32_t	_scopeTrigDelay;
  Epix::Ad9249Config	_adc[10];	/**< Ad9249ReadoutGroup [10]
Ad9249ConfigGroup [10] */
  uint32_t	_testChannel;	/**< AdcTester */
  uint32_t	_testDataMask;
  uint32_t	_testPattern;
  uint32_t	_testSamples;
  uint32_t	_testTimeout;
  uint32_t	_testRequest;
};
#pragma pack(pop)

/** @class Quad10kaConfigV2

  
*/

#pragma pack(push,4)

class Quad10kaConfigV2 {
public:
  enum { FirmwareHashMax = 64 };
  enum { FirmwareDescMax = 256 };
  Quad10kaConfigV2(uint32_t arg__baseClockFrequency, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint32_t arg__firmwareVersion, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, const char* arg__firmwareHash, const char* arg__firmwareDesc, uint32_t arg__dcdcEn, uint32_t arg__asicAnaEn, uint32_t arg__asicDigEn, uint32_t arg__ddrVttEn, uint32_t arg__trigSrcSel, uint32_t arg__vguardDac, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0Width, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint8_t arg_asicAcqForce, uint8_t arg_asicR0Force, uint8_t arg_asicPPmatForce, uint8_t arg_asicSyncForce, uint8_t arg_asicRoClkForce, uint8_t arg_asicAcqValue, uint8_t arg_asicR0Value, uint8_t arg_asicPPmatValue, uint8_t arg_asicSyncValue, uint8_t arg_asicRoClkValue, uint32_t arg__dummyAcqEn, uint32_t arg__asicSyncInjEn, uint32_t arg__asicSyncInjDly, uint32_t arg__adcPipelineDelay, uint32_t arg__testData, uint32_t arg__overSampleEn, uint32_t arg__overSampleSize, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeTrigMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsamplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, uint32_t arg__scopeTrigDelay, const Epix::Ad9249Config* arg__adc, uint32_t arg__testChannel, uint32_t arg__testDataMask, uint32_t arg__testPattern, uint32_t arg__testSamples, uint32_t arg__testTimeout, uint32_t arg__testRequest);
  Quad10kaConfigV2() {}
  Quad10kaConfigV2(const Quad10kaConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Quad10kaConfigV2& operator=(const Quad10kaConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Global */
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  /** AxiVersion (RO) */
  uint32_t firmwareVersion() const { return _firmwareVersion; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  const char* firmwareHash() const { return _firmwareHash; }
  const char* firmwareDesc() const { return _firmwareDesc; }
  /** SystemRegs */
  uint32_t dcdcEn() const { return _dcdcEn; }
  uint32_t asicAnaEn() const { return _asicAnaEn; }
  uint32_t asicDigEn() const { return _asicDigEn; }
  uint32_t ddrVttEn() const { return _ddrVttEn; }
  uint32_t trigSrcSel() const { return _trigSrcSel; }
  uint32_t vguardDac() const { return _vguardDac; }
  /** AcqCore */
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint8_t asicAcqForce() const { return uint8_t(this->_asicForce & 0x1); }
  uint8_t asicR0Force() const { return uint8_t((this->_asicForce>>1) & 0x1); }
  uint8_t asicPPmatForce() const { return uint8_t((this->_asicForce>>2) & 0x1); }
  uint8_t asicSyncForce() const { return uint8_t((this->_asicForce>>3) & 0x1); }
  uint8_t asicRoClkForce() const { return uint8_t((this->_asicForce>>4) & 0x1); }
  uint8_t asicAcqValue() const { return uint8_t(this->_asicForceValue & 0x1); }
  uint8_t asicR0Value() const { return uint8_t((this->_asicForceValue>>1) & 0x1); }
  uint8_t asicPPmatValue() const { return uint8_t((this->_asicForceValue>>2) & 0x1); }
  uint8_t asicSyncValue() const { return uint8_t((this->_asicForceValue>>3) & 0x1); }
  uint8_t asicRoClkValue() const { return uint8_t((this->_asicForceValue>>4) & 0x1); }
  uint32_t dummyAcqEn() const { return _dummyAcqEn; }
  uint32_t asicSyncInjEn() const { return _asicSyncInjEn; }
  uint32_t asicSyncInjDly() const { return _asicSyncInjDly; }
  /** RdoutCore */
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t testData() const { return _testData; }
  uint32_t overSampleEn() const { return _overSampleEn; }
  uint32_t overSampleSize() const { return _overSampleSize; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0x1f); }
  uint8_t scopeTrigMode() const { return uint8_t((this->_Scope>>7) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsamplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x7f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>7) & 0x7f); }
  uint32_t scopeTrigDelay() const { return _scopeTrigDelay; }
  /** Ad9249ReadoutGroup [10]
Ad9249ConfigGroup [10] */
  const Epix::Ad9249Config& adc(uint32_t i0) const { return _adc[i0]; }
  /** AdcTester */
  uint32_t testChannel() const { return _testChannel; }
  uint32_t testDataMask() const { return _testDataMask; }
  uint32_t testPattern() const { return _testPattern; }
  uint32_t testSamples() const { return _testSamples; }
  uint32_t testTimeout() const { return _testTimeout; }
  uint32_t testRequest() const { return _testRequest; }
  static uint32_t _sizeof() { return (((((((((((((((((((((((((((((((((((((((24+(1*(FirmwareHashMax)))+(1*(FirmwareDescMax)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(Epix::Ad9249Config::_sizeof()*(10)))+4)+4)+4)+4)+4)+4)+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by firmwareHash() method. */
  std::vector<int> firmwareHash_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by firmwareDesc() method. */
  std::vector<int> firmwareDesc_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by adc() method. */
  std::vector<int> adc_shape() const;
private:
  uint32_t	_baseClockFrequency;	/**< Global */
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_firmwareVersion;	/**< AxiVersion (RO) */
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  char	_firmwareHash[FirmwareHashMax];
  char	_firmwareDesc[FirmwareDescMax];
  uint32_t	_dcdcEn;	/**< SystemRegs */
  uint32_t	_asicAnaEn;
  uint32_t	_asicDigEn;
  uint32_t	_ddrVttEn;
  uint32_t	_trigSrcSel;
  uint32_t	_vguardDac;
  uint32_t	_acqToAsicR0Delay;	/**< AcqCore */
  uint32_t	_asicR0Width;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_asicForce;
  uint32_t	_asicForceValue;
  uint32_t	_dummyAcqEn;
  uint32_t	_asicSyncInjEn;
  uint32_t	_asicSyncInjDly;
  uint32_t	_adcPipelineDelay;	/**< RdoutCore */
  uint32_t	_testData;
  uint32_t	_overSampleEn;
  uint32_t	_overSampleSize;
  uint32_t	_Scope;	/**< PseudoScopeCore */
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  uint32_t	_scopeTrigDelay;
  Epix::Ad9249Config	_adc[10];	/**< Ad9249ReadoutGroup [10]
Ad9249ConfigGroup [10] */
  uint32_t	_testChannel;	/**< AdcTester */
  uint32_t	_testDataMask;
  uint32_t	_testPattern;
  uint32_t	_testSamples;
  uint32_t	_testTimeout;
  uint32_t	_testRequest;
};
#pragma pack(pop)

/** @class Config10kaQuadV1

  
*/

#pragma pack(push,4)

class Config10kaQuadV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kaQuadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { _numberOfElements = 4 };
  Config10kaQuadV1(const Epix::PgpEvrConfig& arg__evr, const Epix::Quad10kaConfigV1& arg__quad, const Epix::Elem10kaConfigV1* arg__elem);
  Config10kaQuadV1() {}
  Config10kaQuadV1(const Config10kaQuadV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10kaQuadV1& operator=(const Config10kaQuadV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t numberOfElements() const { return this->_numberOfElements; }
  uint32_t numberOfRows() const;
  uint32_t numberOfReadableRows() const;
  uint32_t numberOfColumns() const;
  uint32_t numberOfCalibrationRows() const;
  uint32_t numberOfEnvironmentalRows() const;
  uint32_t numberOfAsics() const;
  const Epix::PgpEvrConfig& evr() const { return _evr; }
  const Epix::Quad10kaConfigV1& quad() const { return _quad; }
  const Epix::Elem10kaConfigV1& elemCfg(uint32_t i0) const { return _elem[i0]; }
  static uint32_t _sizeof() { return ((((((0+(Epix::PgpEvrConfig::_sizeof()))+(Epix::Quad10kaConfigV1::_sizeof()))+(Epix::Elem10kaConfigV1::_sizeof()*(4)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by elemCfg() method. */
  std::vector<int> elemCfg_shape() const;
private:
  Epix::PgpEvrConfig	_evr;
  Epix::Quad10kaConfigV1	_quad;
  Epix::Elem10kaConfigV1	_elem[4];
};
#pragma pack(pop)

/** @class Config10kaQuadV2

  
*/

#pragma pack(push,4)

class Config10kaQuadV2 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kaQuadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { _numberOfElements = 4 };
  Config10kaQuadV2(const Epix::PgpEvrConfig& arg__evr, const Epix::Quad10kaConfigV2& arg__quad, const Epix::Elem10kaConfigV1* arg__elem);
  Config10kaQuadV2() {}
  Config10kaQuadV2(const Config10kaQuadV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10kaQuadV2& operator=(const Config10kaQuadV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t numberOfElements() const { return this->_numberOfElements; }
  uint32_t numberOfRows() const;
  uint32_t numberOfReadableRows() const;
  uint32_t numberOfColumns() const;
  uint32_t numberOfCalibrationRows() const;
  uint32_t numberOfEnvironmentalRows() const;
  uint32_t numberOfAsics() const;
  const Epix::PgpEvrConfig& evr() const { return _evr; }
  const Epix::Quad10kaConfigV2& quad() const { return _quad; }
  const Epix::Elem10kaConfigV1& elemCfg(uint32_t i0) const { return _elem[i0]; }
  static uint32_t _sizeof() { return ((((((0+(Epix::PgpEvrConfig::_sizeof()))+(Epix::Quad10kaConfigV2::_sizeof()))+(Epix::Elem10kaConfigV1::_sizeof()*(4)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by elemCfg() method. */
  std::vector<int> elemCfg_shape() const;
private:
  Epix::PgpEvrConfig	_evr;
  Epix::Quad10kaConfigV2	_quad;
  Epix::Elem10kaConfigV1	_elem[4];
};
#pragma pack(pop)

/** @class Config10ka2MV1

  
*/

#pragma pack(push,4)

class Config10ka2MV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10ka2MConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { _numberOfElements = 16 };
  Config10ka2MV1(const Epix::PgpEvrConfig& arg__evr, const Epix::Quad10kaConfigV1* arg__quad, const Epix::Elem10kaConfigV1* arg__elem);
  Config10ka2MV1() {}
  Config10ka2MV1(const Config10ka2MV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10ka2MV1& operator=(const Config10ka2MV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t numberOfElements() const { return this->_numberOfElements; }
  uint32_t numberOfRows() const;
  uint32_t numberOfReadableRows() const;
  uint32_t numberOfColumns() const;
  uint32_t numberOfCalibrationRows() const;
  uint32_t numberOfEnvironmentalRows() const;
  uint32_t numberOfAsics() const;
  const Epix::PgpEvrConfig& evr() const { return _evr; }
  const Epix::Quad10kaConfigV1& quad(uint32_t i0) const { return _quad[i0]; }
  const Epix::Elem10kaConfigV1& elemCfg(uint32_t i0) const { return _elem[i0]; }
  static uint32_t _sizeof() { return ((((((0+(Epix::PgpEvrConfig::_sizeof()))+(Epix::Quad10kaConfigV1::_sizeof()*(4)))+(Epix::Elem10kaConfigV1::_sizeof()*(16)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quad() method. */
  std::vector<int> quad_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by elemCfg() method. */
  std::vector<int> elemCfg_shape() const;
private:
  Epix::PgpEvrConfig	_evr;
  Epix::Quad10kaConfigV1	_quad[4];
  Epix::Elem10kaConfigV1	_elem[16];
};
#pragma pack(pop)

/** @class Config10ka2MV2

  
*/

#pragma pack(push,4)

class Config10ka2MV2 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10ka2MConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { _numberOfElements = 16 };
  Config10ka2MV2(const Epix::PgpEvrConfig& arg__evr, const Epix::Quad10kaConfigV2* arg__quad, const Epix::Elem10kaConfigV1* arg__elem);
  Config10ka2MV2() {}
  Config10ka2MV2(const Config10ka2MV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10ka2MV2& operator=(const Config10ka2MV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t numberOfElements() const { return this->_numberOfElements; }
  uint32_t numberOfRows() const;
  uint32_t numberOfReadableRows() const;
  uint32_t numberOfColumns() const;
  uint32_t numberOfCalibrationRows() const;
  uint32_t numberOfEnvironmentalRows() const;
  uint32_t numberOfAsics() const;
  const Epix::PgpEvrConfig& evr() const { return _evr; }
  const Epix::Quad10kaConfigV2& quad(uint32_t i0) const { return _quad[i0]; }
  const Epix::Elem10kaConfigV1& elemCfg(uint32_t i0) const { return _elem[i0]; }
  static uint32_t _sizeof() { return ((((((0+(Epix::PgpEvrConfig::_sizeof()))+(Epix::Quad10kaConfigV2::_sizeof()*(4)))+(Epix::Elem10kaConfigV1::_sizeof()*(16)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quad() method. */
  std::vector<int> quad_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by elemCfg() method. */
  std::vector<int> elemCfg_shape() const;
private:
  Epix::PgpEvrConfig	_evr;
  Epix::Quad10kaConfigV2	_quad[4];
  Epix::Elem10kaConfigV1	_elem[16];
};
#pragma pack(pop)

/** @class ElementV1

  
*/

class ConfigV1;
class Config10KV1;
#pragma pack(push,2)

class ElementV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ElementV1() {}
private:
  ElementV1(const ElementV1&);
  ElementV1& operator=(const ElementV1&);
public:
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint16_t acqCount() const { return uint16_t(this->_second & 0xffff); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config10KV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const GenericPgp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> excludedRows(const Epix::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.lastRowExclusions(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> excludedRows(const Epix::Config10KV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.lastRowExclusions(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> excludedRows(const GenericPgp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.lastRowExclusions(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> excludedRows(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.lastRowExclusions(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> excludedRows(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.lastRowExclusions(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> excludedRows(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.lastRowExclusions(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10KV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const GenericPgp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  uint32_t lastWord(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  static uint32_t _sizeof(const Epix::ConfigV1& cfg) { return (((((((32+(2*(cfg.numberOfRows())*(cfg.numberOfColumns())))+(2*(cfg.lastRowExclusions())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config10KV1& cfg) { return (((((((32+(2*(cfg.numberOfRows())*(cfg.numberOfColumns())))+(2*(cfg.lastRowExclusions())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const GenericPgp::ConfigV1& cfg) { return (((((((32+(2*(cfg.numberOfRows())*(cfg.numberOfColumns())))+(2*(cfg.lastRowExclusions())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_z0;
  uint32_t	_z1;
  uint32_t	_z2;
  //uint16_t	_frame[cfg.numberOfRows()][cfg.numberOfColumns()];
  //uint16_t	_excludedRows[cfg.lastRowExclusions()][cfg.numberOfColumns()];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
  //uint32_t	_lastWord;
};
#pragma pack(pop)

/** @class ElementV2

  
*/

class Config100aV1;
class Config100aV2;
class ConfigSV1;
#pragma pack(push,2)

class ElementV2 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  ElementV2() {}
private:
  ElementV2(const ElementV2&);
  ElementV2& operator=(const ElementV2&);
public:
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint16_t acqCount() const { return uint16_t(this->_second & 0xffff); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> environmentalRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> environmentalRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  uint32_t lastWord(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  static uint32_t _sizeof(const Epix::Config100aV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config100aV2& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::ConfigSV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_z0;
  uint32_t	_z1;
  uint32_t	_z2;
  //uint16_t	_frame[cfg.numberOfReadableRows()][cfg.numberOfColumns()];
  //uint16_t	_calibrationRows[cfg.numberOfCalibrationRows()][cfg.numberOfColumns()];
  //uint16_t	_environmentalRows[cfg.numberOfEnvironmentalRows()][cfg.numberOfColumns()];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
  //uint32_t	_lastWord;
};
#pragma pack(pop)

/** @class ElementV3

  
*/

class Config100aV1;
class Config100aV2;
class ConfigSV1;
class Config10kaV1;
class Config10kaV2;
#pragma pack(push,2)

class ElementV3 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };
  ElementV3() {}
private:
  ElementV3(const ElementV3&);
  ElementV3& operator=(const ElementV3&);
public:
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint16_t acqCount() const { return uint16_t(this->_second & 0xffff); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> frame(const Epix::Config10kaV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> frame(const Epix::Config10kaV2& cfg) const { ptrdiff_t offset=32;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config10kaV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config10kaV2& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 2> environmentalRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config10kaV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 2> environmentalRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config10kaV2& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaV2& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  uint32_t lastWord(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config10kaV2& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  static uint32_t _sizeof(const Epix::Config100aV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config100aV2& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::ConfigSV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config10kaV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config10kaV2& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_z0;
  uint32_t	_z1;
  uint32_t	_z2;
  //uint16_t	_frame[cfg.numberOfReadableRows()][cfg.numberOfColumns()];
  //uint16_t	_calibrationRows[cfg.numberOfCalibrationRows()][cfg.numberOfColumns()];
  //uint32_t	_environmentalRows[cfg.numberOfEnvironmentalRows()][cfg.numberOfColumns()>>1];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
  //uint32_t	_lastWord;
};
#pragma pack(pop)

/** @class ArrayV1

  
*/

class Config10ka2MV1;
class Config10kaQuadV1;
class Config10ka2MV2;
class Config10kaQuadV2;
#pragma pack(push,4)

class ArrayV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kaArray /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ArrayV1() {}
private:
  ArrayV1(const ArrayV1&);
  ArrayV1& operator=(const ArrayV1&);
public:
  uint32_t frameNumber() const { return _frameNumber; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frame(const Epix::Config10ka2MV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frame(const Epix::Config10kaQuadV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frame(const Epix::Config10ka2MV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frame(const Epix::Config10kaQuadV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frame(const Epix::Config10ka2MV1& cfg) const { ptrdiff_t offset=4;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frame(const Epix::Config10kaQuadV1& cfg) const { ptrdiff_t offset=4;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frame(const Epix::Config10ka2MV2& cfg) const { ptrdiff_t offset=4;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frame(const Epix::Config10kaQuadV2& cfg) const { ptrdiff_t offset=4;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10ka2MV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10kaQuadV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10ka2MV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10kaQuadV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10ka2MV1& cfg) const { ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10kaQuadV1& cfg) const { ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10ka2MV2& cfg) const { ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> calibrationRows(const Epix::Config10kaQuadV2& cfg) const { ptrdiff_t offset=4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns())));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10ka2MV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10kaQuadV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10ka2MV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10kaQuadV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10ka2MV1& cfg) const { ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10kaQuadV1& cfg) const { ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10ka2MV2& cfg) const { ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 3> environmentalRows(const Epix::Config10kaQuadV2& cfg) const { ptrdiff_t offset=(4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns())));
  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfElements(), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10ka2MV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaQuadV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10ka2MV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaQuadV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10ka2MV1& cfg) const { ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaQuadV1& cfg) const { ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10ka2MV2& cfg) const { ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaQuadV2& cfg) const { ptrdiff_t offset=((4+(2*(((cfg.numberOfElements())*(cfg.numberOfReadableRows()))*(cfg.numberOfColumns()))))+(2*(((cfg.numberOfElements())*(cfg.numberOfCalibrationRows()))*(cfg.numberOfColumns()))))+(4*(((cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows()))*(cfg.numberOfColumns()>>1)));
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfAsics()); }
  static uint32_t _sizeof(const Epix::Config10ka2MV1& cfg) { return (((((((4+(2*(cfg.numberOfElements())*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfElements())*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Epix::Config10kaQuadV1& cfg) { return (((((((4+(2*(cfg.numberOfElements())*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfElements())*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Epix::Config10ka2MV2& cfg) { return (((((((4+(2*(cfg.numberOfElements())*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfElements())*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Epix::Config10kaQuadV2& cfg) { return (((((((4+(2*(cfg.numberOfElements())*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfElements())*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfElements())*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)-1)/4)*4; }
private:
  uint32_t	_frameNumber;
  //uint16_t	_frame[cfg.numberOfElements()][cfg.numberOfReadableRows()][cfg.numberOfColumns()];
  //uint16_t	_calibrationRows[cfg.numberOfElements()][cfg.numberOfCalibrationRows()][cfg.numberOfColumns()];
  //uint32_t	_environmentalRows[cfg.numberOfElements()][cfg.numberOfEnvironmentalRows()][cfg.numberOfColumns()>>1];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
};
#pragma pack(pop)
} // namespace Epix
} // namespace Pds
#endif // PDS_EPIX_DDL_H
