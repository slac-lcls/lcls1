
// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/psddl/generic1d.ddl.h"

#include <iostream>
namespace Pds {
namespace Generic1D {
int32_t
ConfigV0::data_offset(uint32_t channel) const {
  
    int32_t offset=0;
    if (channel>this->_NChannels) channel=this->_NChannels;
    for(uint32_t k=0; k<channel; k++)
      offset += (this->Length()[k]*this->Depth(k));
    return offset;

}
uint32_t
ConfigV0::Depth(uint32_t channel) const {
  
    switch (Sample_Type(this->SampleType()[channel])) {
    case UINT8: return 1;
    case UINT16: return 2;
    case UINT32: return 4;
    case FLOAT32: return 4;
    case FLOAT64: return 8;
    } 
   return 0;

}
std::ostream& operator<<(std::ostream& str, Generic1D::ConfigV0::Sample_Type enval) {
  const char* val;
  switch (enval) {
  case Generic1D::ConfigV0::UINT8:
    val = "UINT8";
    break;
  case Generic1D::ConfigV0::UINT16:
    val = "UINT16";
    break;
  case Generic1D::ConfigV0::UINT32:
    val = "UINT32";
    break;
  case Generic1D::ConfigV0::FLOAT32:
    val = "FLOAT32";
    break;
  case Generic1D::ConfigV0::FLOAT64:
    val = "FLOAT64";
    break;
  default:
    return str << "Sample_Type(" << int(enval) << ")";
  }
  return str << val;
}
ndarray<const uint8_t, 1>
DataV0::data_u8(const Generic1D::ConfigV0& cfg, uint32_t channel) const {
  
    if (cfg.SampleType()[channel] != ConfigV0::UINT8) return ndarray<const uint8_t, 1>();
    return make_ndarray(_int_data().data()+cfg.data_offset(channel), cfg.Length()[channel]);

}
ndarray<const uint16_t, 1>
DataV0::data_u16(const Generic1D::ConfigV0& cfg, uint32_t channel) const {
  
    if (cfg.SampleType()[channel] != ConfigV0::UINT16) return ndarray<const uint16_t, 1>();
    return make_ndarray((const uint16_t*)(_int_data().data()+cfg.data_offset(channel)), cfg.Length()[channel]);

}
ndarray<const uint32_t, 1>
DataV0::data_u32(const Generic1D::ConfigV0& cfg, uint32_t channel) const {
  
    if (cfg.SampleType()[channel] != ConfigV0::UINT32) return ndarray<const uint32_t, 1>();
    return make_ndarray((const uint32_t*)(_int_data().data()+cfg.data_offset(channel)), cfg.Length()[channel]);

}
ndarray<const float, 1>
DataV0::data_f32(const Generic1D::ConfigV0& cfg, uint32_t channel) const {
  
    if (cfg.SampleType()[channel] != ConfigV0::FLOAT32) return ndarray<const float, 1>();
    return make_ndarray((const float*)(_int_data().data()+cfg.data_offset(channel)), cfg.Length()[channel]);

}
ndarray<const double, 1>
DataV0::data_f64(const Generic1D::ConfigV0& cfg, uint32_t channel) const {
  
    if (cfg.SampleType()[channel] != ConfigV0::FLOAT64) return ndarray<const double, 1>();
    return make_ndarray((const double*)(_int_data().data()+cfg.data_offset(channel)), cfg.Length()[channel]);

}
} // namespace Generic1D
} // namespace Pds
