
// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/psddl/ipimb.ddl.h"

#include <iostream>
namespace Pds {
namespace Ipimb {
ndarray<const uint8_t, 1>
ConfigV1::capacitorValues() const {
  
    /* return type is actually ndarray<uint8_t, 1> (at least for now) */
    ndarray<uint8_t, 1> cap = make_ndarray<uint8_t>(4);
    for (int ch = 0; ch != 4; ++ ch) {
      cap[ch] = uint8_t((this->chargeAmpRange() >> (ch*2)) & 0x3);
    }
    return cap;

}
std::ostream& operator<<(std::ostream& str, Ipimb::ConfigV1::CapacitorValue enval) {
  const char* val;
  switch (enval) {
  case Ipimb::ConfigV1::c_1pF:
    val = "c_1pF";
    break;
  case Ipimb::ConfigV1::c_100pF:
    val = "c_100pF";
    break;
  case Ipimb::ConfigV1::c_10nF:
    val = "c_10nF";
    break;
  default:
    return str << "CapacitorValue(" << int(enval) << ")";
  }
  return str << val;
}
ndarray<const uint8_t, 1>
ConfigV2::capacitorValues() const {
  
    /* return type is actually ndarray<uint8_t, 1> (at least for now) */
    ndarray<uint8_t, 1> cap = make_ndarray<uint8_t>(4);
    for (int ch = 0; ch != 4; ++ ch) {
      cap[ch] = uint8_t((this->chargeAmpRange() >> (ch*4)) & 0xf);
    }
    return cap;

}
std::ostream& operator<<(std::ostream& str, Ipimb::ConfigV2::CapacitorValue enval) {
  const char* val;
  switch (enval) {
  case Ipimb::ConfigV2::c_1pF:
    val = "c_1pF";
    break;
  case Ipimb::ConfigV2::c_4p7pF:
    val = "c_4p7pF";
    break;
  case Ipimb::ConfigV2::c_24pF:
    val = "c_24pF";
    break;
  case Ipimb::ConfigV2::c_120pF:
    val = "c_120pF";
    break;
  case Ipimb::ConfigV2::c_620pF:
    val = "c_620pF";
    break;
  case Ipimb::ConfigV2::c_3p3nF:
    val = "c_3p3nF";
    break;
  case Ipimb::ConfigV2::c_10nF:
    val = "c_10nF";
    break;
  case Ipimb::ConfigV2::expert:
    val = "expert";
    break;
  default:
    return str << "CapacitorValue(" << int(enval) << ")";
  }
  return str << val;
}
float
DataV1::channel0Volts() const {
  return float(this->_channel0)*3.3/65535;
}
float
DataV1::channel1Volts() const {
  return float(this->_channel1)*3.3/65535;
}
float
DataV1::channel2Volts() const {
  return float(this->_channel2)*3.3/65535;
}
float
DataV1::channel3Volts() const {
  return float(this->_channel3)*3.3/65535;
}
float
DataV2::channel0Volts() const {
  return float(this->_channel0)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel1Volts() const {
  return float(this->_channel1)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel2Volts() const {
  return float(this->_channel2)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel3Volts() const {
  return float(this->_channel3)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel0psVolts() const {
  return float(this->_channel0ps)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel1psVolts() const {
  return float(this->_channel1ps)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel2psVolts() const {
  return float(this->_channel2ps)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
float
DataV2::channel3psVolts() const {
  return float(this->_channel3ps)*ipimbAdcRange/(ipimbAdcSteps - 1);
}
} // namespace Ipimb
} // namespace Pds
