#ifndef PDS_ENCODER_DDL_H
#define PDS_ENCODER_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Encoder {

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EncoderConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum count_mode_type {
    WRAP_FULL,
    LIMIT,
    HALT,
    WRAP_PRESET,
    COUNT_END,
  };
  enum quad_mode {
    CLOCK_DIR,
    X1,
    X2,
    X4,
    QUAD_END,
  };
  ConfigV1(uint32_t arg__chan_num, Encoder::ConfigV1::count_mode_type arg__count_mode, Encoder::ConfigV1::quad_mode arg__quadrature_mode, uint32_t arg__input_num, uint32_t arg__input_rising, uint32_t arg__ticks_per_sec)
    : _chan_num(arg__chan_num), _count_mode(arg__count_mode), _quadrature_mode(arg__quadrature_mode), _input_num(arg__input_num), _input_rising(arg__input_rising), _ticks_per_sec(arg__ticks_per_sec)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t chan_num() const { return _chan_num; }
  Encoder::ConfigV1::count_mode_type count_mode() const { return Encoder::ConfigV1::count_mode_type(_count_mode); }
  Encoder::ConfigV1::quad_mode quadrature_mode() const { return Encoder::ConfigV1::quad_mode(_quadrature_mode); }
  uint32_t input_num() const { return _input_num; }
  uint32_t input_rising() const { return _input_rising; }
  uint32_t ticks_per_sec() const { return _ticks_per_sec; }
  static uint32_t _sizeof() { return 24; }
private:
  uint32_t	_chan_num;
  uint32_t	_count_mode;
  uint32_t	_quadrature_mode;
  uint32_t	_input_num;
  uint32_t	_input_rising;
  uint32_t	_ticks_per_sec;
};
std::ostream& operator<<(std::ostream& str, Encoder::ConfigV1::count_mode_type enval);
std::ostream& operator<<(std::ostream& str, Encoder::ConfigV1::quad_mode enval);

/** @class ConfigV2

  
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_EncoderConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum count_mode_type {
    WRAP_FULL,
    LIMIT,
    HALT,
    WRAP_PRESET,
    COUNT_END,
  };
  enum quad_mode {
    CLOCK_DIR,
    X1,
    X2,
    X4,
    QUAD_END,
  };
  ConfigV2(uint32_t arg__chan_mask, Encoder::ConfigV2::count_mode_type arg__count_mode, Encoder::ConfigV2::quad_mode arg__quadrature_mode, uint32_t arg__input_num, uint32_t arg__input_rising, uint32_t arg__ticks_per_sec)
    : _chan_mask(arg__chan_mask), _count_mode(arg__count_mode), _quadrature_mode(arg__quadrature_mode), _input_num(arg__input_num), _input_rising(arg__input_rising), _ticks_per_sec(arg__ticks_per_sec)
  {
  }
  ConfigV2() {}
  ConfigV2(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV2& operator=(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t chan_mask() const { return _chan_mask; }
  Encoder::ConfigV2::count_mode_type count_mode() const { return Encoder::ConfigV2::count_mode_type(_count_mode); }
  Encoder::ConfigV2::quad_mode quadrature_mode() const { return Encoder::ConfigV2::quad_mode(_quadrature_mode); }
  uint32_t input_num() const { return _input_num; }
  uint32_t input_rising() const { return _input_rising; }
  uint32_t ticks_per_sec() const { return _ticks_per_sec; }
  static uint32_t _sizeof() { return 24; }
private:
  uint32_t	_chan_mask;
  uint32_t	_count_mode;
  uint32_t	_quadrature_mode;
  uint32_t	_input_num;
  uint32_t	_input_rising;
  uint32_t	_ticks_per_sec;
};
std::ostream& operator<<(std::ostream& str, Encoder::ConfigV2::count_mode_type enval);
std::ostream& operator<<(std::ostream& str, Encoder::ConfigV2::quad_mode enval);

/** @class DataV1

  
*/


class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EncoderData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  DataV1() {}
  DataV1(const DataV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  DataV1& operator=(const DataV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t timestamp() const { return _33mhz_timestamp; }
  uint32_t encoder_count() const { return _encoder_count; }
  /** Lower 24 bits of encoder_count as signed integer value. */
  int32_t value() const;
  static uint32_t _sizeof() { return 8; }
private:
  uint32_t	_33mhz_timestamp;
  uint32_t	_encoder_count;
};

/** @class DataV2

  
*/


class DataV2 {
public:
  enum { TypeId = Pds::TypeId::Id_EncoderData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { NEncoders = 3 /**< Number of encoders. */ };
  DataV2(uint32_t arg__33mhz_timestamp, const uint32_t* arg__encoder_count)
    : _33mhz_timestamp(arg__33mhz_timestamp)
  {
    if (arg__encoder_count) std::copy(arg__encoder_count, arg__encoder_count+(3), &_encoder_count[0]);
  }
  DataV2() {}
  DataV2(const DataV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  DataV2& operator=(const DataV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t timestamp() const { return _33mhz_timestamp; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> encoder_count(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_encoder_count[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NEncoders);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> encoder_count() const { return make_ndarray(&_encoder_count[0], NEncoders); }
  /** Lower 24 bits of encoder_count as signed integer value. */
  int32_t value(uint32_t i) const;
  static uint32_t _sizeof() { return ((((4+(4*(NEncoders)))+4)-1)/4)*4; }
private:
  uint32_t	_33mhz_timestamp;
  uint32_t	_encoder_count[NEncoders];
};
} // namespace Encoder
} // namespace Pds
#endif // PDS_ENCODER_DDL_H
