#ifndef PDS_BLD_DDL_H
#define PDS_BLD_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/psddl/acqiris.ddl.h"
#include "pdsdata/psddl/camera.ddl.h"
#include "pdsdata/psddl/ipimb.ddl.h"
#include "pdsdata/psddl/lusi.ddl.h"
#include "pdsdata/psddl/pulnix.ddl.h"
#include "pdsdata/psddl/usdusb.ddl.h"
namespace Pds {
namespace Bld {

/** @class BldDataFEEGasDetEnergy

  Four energy measurements from Front End Enclosure Gas Detector.
               PV names: GDET:FEE1:11:ENRC, GDET:FEE1:12:ENRC, GDET:FEE1:21:ENRC, GDET:FEE1:22:ENRC.
*/

#pragma pack(push,4)

class BldDataFEEGasDetEnergy {
public:
  enum { TypeId = Pds::TypeId::Id_FEEGasDetEnergy /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataFEEGasDetEnergy(double arg__f_11_ENRC, double arg__f_12_ENRC, double arg__f_21_ENRC, double arg__f_22_ENRC)
    : _f_11_ENRC(arg__f_11_ENRC), _f_12_ENRC(arg__f_12_ENRC), _f_21_ENRC(arg__f_21_ENRC), _f_22_ENRC(arg__f_22_ENRC)
  {
  }
  BldDataFEEGasDetEnergy() {}
  /** Value of GDET:FEE1:11:ENRC, in mJ. */
  double f_11_ENRC() const { return _f_11_ENRC; }
  /** Value of GDET:FEE1:12:ENRC, in mJ. */
  double f_12_ENRC() const { return _f_12_ENRC; }
  /** Value of GDET:FEE1:21:ENRC, in mJ. */
  double f_21_ENRC() const { return _f_21_ENRC; }
  /** Value of GDET:FEE1:22:ENRC, in mJ. */
  double f_22_ENRC() const { return _f_22_ENRC; }
  static uint32_t _sizeof() { return 32; }
private:
  double	_f_11_ENRC;	/**< Value of GDET:FEE1:11:ENRC, in mJ. */
  double	_f_12_ENRC;	/**< Value of GDET:FEE1:12:ENRC, in mJ. */
  double	_f_21_ENRC;	/**< Value of GDET:FEE1:21:ENRC, in mJ. */
  double	_f_22_ENRC;	/**< Value of GDET:FEE1:22:ENRC, in mJ. */
};
#pragma pack(pop)

/** @class BldDataFEEGasDetEnergyV1

  Six energy measurements from Front End Enclosure Gas Detector.
   PV names: GDET:FEE1:241:ENRC, GDET:FEE1:242:ENRC, 
    GDET:FEE1:361:ENRC, GDET:FEE1:362:ENRC, 
    GDET:FEE1:363:ENRC, and GDET:FEE1:364:ENRC 
   Each pair of methods (e.g. f_11_ENRC(), f_12_ENRC() contains
   identical measurements using two different phototubes.  "11" and "12"
   are before the gas attenuation.  "21" and "22" are after gas
   attenuation.
   "63" and "64" are duplicate measurements of "21" and "22" respectively. 
    The difference is that they cover a smaller (10%) dynamic range. 
    When the beam is weak, 361 and 362 don't have good S/N, these 2 extra PVs should be used instead.  Dehong Zhang suggests that the threshold
    for "weak" is around 0.5 mJ.
*/

#pragma pack(push,4)

class BldDataFEEGasDetEnergyV1 {
public:
  enum { TypeId = Pds::TypeId::Id_FEEGasDetEnergy /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataFEEGasDetEnergyV1(double arg__f_11_ENRC, double arg__f_12_ENRC, double arg__f_21_ENRC, double arg__f_22_ENRC, double arg__f_63_ENRC, double arg__f_64_ENRC)
    : _f_11_ENRC(arg__f_11_ENRC), _f_12_ENRC(arg__f_12_ENRC), _f_21_ENRC(arg__f_21_ENRC), _f_22_ENRC(arg__f_22_ENRC), _f_63_ENRC(arg__f_63_ENRC), _f_64_ENRC(arg__f_64_ENRC)
  {
  }
  BldDataFEEGasDetEnergyV1() {}
  /** First energy measurement (mJ) before attenuation. (pv name GDET:FEE1:241:ENRC) */
  double f_11_ENRC() const { return _f_11_ENRC; }
  /** Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:242:ENRC) */
  double f_12_ENRC() const { return _f_12_ENRC; }
  /** First energy measurement (mJ) after attenuation. (pv name  GDET:FEE1:361:ENRC) */
  double f_21_ENRC() const { return _f_21_ENRC; }
  /** Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:362:ENRC) */
  double f_22_ENRC() const { return _f_22_ENRC; }
  /** First energy measurement (mJ) for small signals (<0.5 mJ), after attenuation. (pv name GDET:FEE1:363:ENRC) */
  double f_63_ENRC() const { return _f_63_ENRC; }
  /** Second (duplicate!) energy measurement (mJ) for small signals (<0.5mJ), after attenutation. (pv name GDET:FEE1:364:ENRC) */
  double f_64_ENRC() const { return _f_64_ENRC; }
  static uint32_t _sizeof() { return 48; }
private:
  double	_f_11_ENRC;	/**< First energy measurement (mJ) before attenuation. (pv name GDET:FEE1:241:ENRC) */
  double	_f_12_ENRC;	/**< Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:242:ENRC) */
  double	_f_21_ENRC;	/**< First energy measurement (mJ) after attenuation. (pv name  GDET:FEE1:361:ENRC) */
  double	_f_22_ENRC;	/**< Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:362:ENRC) */
  double	_f_63_ENRC;	/**< First energy measurement (mJ) for small signals (<0.5 mJ), after attenuation. (pv name GDET:FEE1:363:ENRC) */
  double	_f_64_ENRC;	/**< Second (duplicate!) energy measurement (mJ) for small signals (<0.5mJ), after attenutation. (pv name GDET:FEE1:364:ENRC) */
};
#pragma pack(pop)

/** @class BldDataEBeamV0

  Beam parameters.
*/

#pragma pack(push,4)

class BldDataEBeamV0 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
  };
  BldDataEBeamV0(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY)
  {
  }
  BldDataEBeamV0() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  static uint32_t _sizeof() { return 52; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV0::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV1

  
*/

#pragma pack(push,4)

class BldDataEBeamV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
  };
  BldDataEBeamV1(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2)
  {
  }
  BldDataEBeamV1() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  static uint32_t _sizeof() { return 60; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV1::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV2

  
*/

#pragma pack(push,4)

class BldDataEBeamV2 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
  };
  BldDataEBeamV2(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2)
  {
  }
  BldDataEBeamV2() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam energy in MeV. */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  static uint32_t _sizeof() { return 68; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam energy in MeV. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV2::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV3

  
*/

#pragma pack(push,4)

class BldDataEBeamV3 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
  };
  BldDataEBeamV3(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1)
  {
  }
  BldDataEBeamV3() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV3::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV4

  
*/

#pragma pack(push,4)

class BldDataEBeamV4 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 4 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
  };
  BldDataEBeamV4(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY)
  {
  }
  BldDataEBeamV4() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  static uint32_t _sizeof() { return 116; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV4::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV5

  
*/

#pragma pack(push,4)

class BldDataEBeamV5 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 5 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
    EbeamXTCAVAmplDamage = 0x4000,
    EbeamXTCAVPhaseDamage = 0x8000,
    EbeamDumpChargeDamage = 0x10000,
  };
  BldDataEBeamV5(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY, double arg__fEbeamXTCAVAmpl, double arg__fEbeamXTCAVPhase, double arg__fEbeamDumpCharge)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY), _fEbeamXTCAVAmpl(arg__fEbeamXTCAVAmpl), _fEbeamXTCAVPhase(arg__fEbeamXTCAVPhase), _fEbeamDumpCharge(arg__fEbeamDumpCharge)
  {
  }
  BldDataEBeamV5() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  /** XTCAV Amplitude in MVolt. */
  double ebeamXTCAVAmpl() const { return _fEbeamXTCAVAmpl; }
  /** XTCAV Phase in degrees. */
  double ebeamXTCAVPhase() const { return _fEbeamXTCAVPhase; }
  /** Bunch charge at Dump in num. electrons */
  double ebeamDumpCharge() const { return _fEbeamDumpCharge; }
  static uint32_t _sizeof() { return 140; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
  double	_fEbeamXTCAVAmpl;	/**< XTCAV Amplitude in MVolt. */
  double	_fEbeamXTCAVPhase;	/**< XTCAV Phase in degrees. */
  double	_fEbeamDumpCharge;	/**< Bunch charge at Dump in num. electrons */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV5::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV6

  
*/

#pragma pack(push,4)

class BldDataEBeamV6 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 6 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
    EbeamXTCAVAmplDamage = 0x4000,
    EbeamXTCAVPhaseDamage = 0x8000,
    EbeamDumpChargeDamage = 0x10000,
    EbeamPhotonEnergyDamage = 0x20000,
  };
  BldDataEBeamV6(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY, double arg__fEbeamXTCAVAmpl, double arg__fEbeamXTCAVPhase, double arg__fEbeamDumpCharge, double arg__fEbeamPhotonEnergy, double arg__fEbeamLTU250, double arg__fEbeamLTU450)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY), _fEbeamXTCAVAmpl(arg__fEbeamXTCAVAmpl), _fEbeamXTCAVPhase(arg__fEbeamXTCAVPhase), _fEbeamDumpCharge(arg__fEbeamDumpCharge), _fEbeamPhotonEnergy(arg__fEbeamPhotonEnergy), _fEbeamLTU250(arg__fEbeamLTU250), _fEbeamLTU450(arg__fEbeamLTU450)
  {
  }
  BldDataEBeamV6() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  /** XTCAV Amplitude in MVolt. */
  double ebeamXTCAVAmpl() const { return _fEbeamXTCAVAmpl; }
  /** XTCAV Phase in degrees. */
  double ebeamXTCAVPhase() const { return _fEbeamXTCAVPhase; }
  /** Bunch charge at Dump in num. electrons */
  double ebeamDumpCharge() const { return _fEbeamDumpCharge; }
  /** computed photon energy, in eV */
  double ebeamPhotonEnergy() const { return _fEbeamPhotonEnergy; }
  /** LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double ebeamLTU250() const { return _fEbeamLTU250; }
  /** LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
  double ebeamLTU450() const { return _fEbeamLTU450; }
  static uint32_t _sizeof() { return 164; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
  double	_fEbeamXTCAVAmpl;	/**< XTCAV Amplitude in MVolt. */
  double	_fEbeamXTCAVPhase;	/**< XTCAV Phase in degrees. */
  double	_fEbeamDumpCharge;	/**< Bunch charge at Dump in num. electrons */
  double	_fEbeamPhotonEnergy;	/**< computed photon energy, in eV */
  double	_fEbeamLTU250;	/**< LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double	_fEbeamLTU450;	/**< LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV6::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEBeamV7

  BldDataEBeamV7 is the same as BldDataEBeamV6.
A sign-error error was discovered in the calculation of the photon energy that goes into the ebeam bld.
This is fixed on the accelerator side, but we will increment the ebeam bld version number to V7 so the
data is clearly marked as changed.
*/

#pragma pack(push,4)

class BldDataEBeamV7 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 7 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
    EbeamXTCAVAmplDamage = 0x4000,
    EbeamXTCAVPhaseDamage = 0x8000,
    EbeamDumpChargeDamage = 0x10000,
    EbeamPhotonEnergyDamage = 0x20000,
  };
  BldDataEBeamV7(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY, double arg__fEbeamXTCAVAmpl, double arg__fEbeamXTCAVPhase, double arg__fEbeamDumpCharge, double arg__fEbeamPhotonEnergy, double arg__fEbeamLTU250, double arg__fEbeamLTU450)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY), _fEbeamXTCAVAmpl(arg__fEbeamXTCAVAmpl), _fEbeamXTCAVPhase(arg__fEbeamXTCAVPhase), _fEbeamDumpCharge(arg__fEbeamDumpCharge), _fEbeamPhotonEnergy(arg__fEbeamPhotonEnergy), _fEbeamLTU250(arg__fEbeamLTU250), _fEbeamLTU450(arg__fEbeamLTU450)
  {
  }
  BldDataEBeamV7() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  /** XTCAV Amplitude in MVolt. */
  double ebeamXTCAVAmpl() const { return _fEbeamXTCAVAmpl; }
  /** XTCAV Phase in degrees. */
  double ebeamXTCAVPhase() const { return _fEbeamXTCAVPhase; }
  /** Bunch charge at Dump in num. electrons */
  double ebeamDumpCharge() const { return _fEbeamDumpCharge; }
  /** computed photon energy, in eV */
  double ebeamPhotonEnergy() const { return _fEbeamPhotonEnergy; }
  /** LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double ebeamLTU250() const { return _fEbeamLTU250; }
  /** LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
  double ebeamLTU450() const { return _fEbeamLTU450; }
  static uint32_t _sizeof() { return 164; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
  double	_fEbeamXTCAVAmpl;	/**< XTCAV Amplitude in MVolt. */
  double	_fEbeamXTCAVPhase;	/**< XTCAV Phase in degrees. */
  double	_fEbeamDumpCharge;	/**< Bunch charge at Dump in num. electrons */
  double	_fEbeamPhotonEnergy;	/**< computed photon energy, in eV */
  double	_fEbeamLTU250;	/**< LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double	_fEbeamLTU450;	/**< LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV7::DamageMask enval);
#pragma pack(pop)

/** @class BldDataEOrbitsV0

  Orbit parameters.
*/

#pragma pack(push,4)

class BldDataEOrbitsV0 {
public:
  enum { TypeId = Pds::TypeId::Id_EOrbits /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataEOrbitsV0(uint32_t arg__nBPMS, const double* arg__fBPM_X, const double* arg__fBPM_Y, const double* arg__fBPM_TMIT)
    : _nBPMS(arg__nBPMS)
  {
    if (arg__fBPM_X and (this->_nBPMS)) {
      ptrdiff_t offset = 4;
      double* data = reinterpret_cast<double*>(((char*)this)+offset);
      std::copy(arg__fBPM_X, arg__fBPM_X+(this->_nBPMS), data);
    }
    if (arg__fBPM_Y and (this->_nBPMS)) {
      ptrdiff_t offset = 4+(8*(this->_nBPMS));
      double* data = reinterpret_cast<double*>(((char*)this)+offset);
      std::copy(arg__fBPM_Y, arg__fBPM_Y+(this->_nBPMS), data);
    }
    if (arg__fBPM_TMIT and (this->_nBPMS)) {
      ptrdiff_t offset = (4+(8*(this->_nBPMS)))+(8*(this->_nBPMS));
      double* data = reinterpret_cast<double*>(((char*)this)+offset);
      std::copy(arg__fBPM_TMIT, arg__fBPM_TMIT+(this->_nBPMS), data);
    }
  }
  BldDataEOrbitsV0(uint32_t nBPMS)
    : _nBPMS(nBPMS)
  {
  }
  BldDataEOrbitsV0() {}
  BldDataEOrbitsV0(const BldDataEOrbitsV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataEOrbitsV0& operator=(const BldDataEOrbitsV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Number of BPM in each array */
  uint32_t nBPMS() const { return _nBPMS; }
  /** Array of BPM X values (mm)

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> fBPM_X(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_nBPMS);
  }
  /** Array of BPM X values (mm)

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> fBPM_X() const { ptrdiff_t offset=4;
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_nBPMS); }
  /** Array of BPM Y values (mm)

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> fBPM_Y(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4+(8*(this->_nBPMS));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_nBPMS);
  }
  /** Array of BPM Y values (mm)

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> fBPM_Y() const { ptrdiff_t offset=4+(8*(this->_nBPMS));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_nBPMS); }
  /** Array of BPM TMIT values (Nel)

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> fBPM_TMIT(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(4+(8*(this->_nBPMS)))+(8*(this->_nBPMS));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_nBPMS);
  }
  /** Array of BPM TMIT values (Nel)

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> fBPM_TMIT() const { ptrdiff_t offset=(4+(8*(this->_nBPMS)))+(8*(this->_nBPMS));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_nBPMS); }
  uint32_t _sizeof() const { return ((((((4+(8*(this->_nBPMS)))+(8*(this->_nBPMS)))+(8*(this->_nBPMS)))+4)-1)/4)*4; }
private:
  uint32_t	_nBPMS;	/**< Number of BPM in each array */
  //double	_fBPM_X[this->_nBPMS];
  //double	_fBPM_Y[this->_nBPMS];
  //double	_fBPM_TMIT[this->_nBPMS];
};
#pragma pack(pop)

/** @class BldDataPhaseCavity

  PV names: UND:R02:IOC:16:BAT:FitTime1, UND:R02:IOC:16:BAT:FitTime2,
                UND:R02:IOC:16:BAT:Charge1,  UND:R02:IOC:16:BAT:Charge2
*/

#pragma pack(push,4)

class BldDataPhaseCavity {
public:
  enum { TypeId = Pds::TypeId::Id_PhaseCavity /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataPhaseCavity(double arg__fFitTime1, double arg__fFitTime2, double arg__fCharge1, double arg__fCharge2)
    : _fFitTime1(arg__fFitTime1), _fFitTime2(arg__fFitTime2), _fCharge1(arg__fCharge1), _fCharge2(arg__fCharge2)
  {
  }
  BldDataPhaseCavity() {}
  /** UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds. */
  double fitTime1() const { return _fFitTime1; }
  /** UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds. */
  double fitTime2() const { return _fFitTime2; }
  /** UND:R02:IOC:16:BAT:Charge1 value in pico-columbs. */
  double charge1() const { return _fCharge1; }
  /** UND:R02:IOC:16:BAT:Charge2 value in pico-columbs. */
  double charge2() const { return _fCharge2; }
  static uint32_t _sizeof() { return 32; }
private:
  double	_fFitTime1;	/**< UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds. */
  double	_fFitTime2;	/**< UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds. */
  double	_fCharge1;	/**< UND:R02:IOC:16:BAT:Charge1 value in pico-columbs. */
  double	_fCharge2;	/**< UND:R02:IOC:16:BAT:Charge2 value in pico-columbs. */
};
#pragma pack(pop)

/** @class BldDataPhaseCavityV1

  PV names: UND:R02:IOC:16:BAT:FitTime1, UND:R02:IOC:16:BAT:FitTime2,
                UND:R02:IOC:16:BAT:Charge1,  UND:R02:IOC:16:BAT:Charge2
*/

#pragma pack(push,4)

class BldDataPhaseCavityV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PhaseCavity /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataPhaseCavityV1(double arg__fFitTime1, double arg__fFitTime2, double arg__fCharge1, double arg__fCharge2)
    : _fFitTime1(arg__fFitTime1), _fFitTime2(arg__fFitTime2), _fCharge1(arg__fCharge1), _fCharge2(arg__fCharge2)
  {
  }
  BldDataPhaseCavityV1() {}
  /** UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds. */
  double fitTime1() const { return _fFitTime1; }
  /** UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds. */
  double fitTime2() const { return _fFitTime2; }
  /** UND:R02:IOC:16:BAT:Charge1 value in pico-columbs. */
  double charge1() const { return _fCharge1; }
  /** UND:R02:IOC:16:BAT:Charge2 value in pico-columbs. */
  double charge2() const { return _fCharge2; }
  static uint32_t _sizeof() { return 32; }
private:
  double	_fFitTime1;	/**< UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds. */
  double	_fFitTime2;	/**< UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds. */
  double	_fCharge1;	/**< UND:R02:IOC:16:BAT:Charge1 value in pico-columbs. */
  double	_fCharge2;	/**< UND:R02:IOC:16:BAT:Charge2 value in pico-columbs. */
};
#pragma pack(pop)

/** @class BldDataIpimbV0

  Combined structure which includes Ipimb.DataV1, Ipimb.ConfigV1, and
            Lusi.IpmFexV1 objects.
*/

#pragma pack(push,4)

class BldDataIpimbV0 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedIpimb /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataIpimbV0() {}
  BldDataIpimbV0(const BldDataIpimbV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataIpimbV0& operator=(const BldDataIpimbV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  const Ipimb::DataV1& ipimbData() const { return _ipimbData; }
  const Ipimb::ConfigV1& ipimbConfig() const { return _ipimbConfig; }
  const Lusi::IpmFexV1& ipmFexData() const { return _ipmFexData; }
  static uint32_t _sizeof() { return ((((((0+(Ipimb::DataV1::_sizeof()))+(Ipimb::ConfigV1::_sizeof()))+(Lusi::IpmFexV1::_sizeof()))+4)-1)/4)*4; }
private:
  Ipimb::DataV1	_ipimbData;
  Ipimb::ConfigV1	_ipimbConfig;
  Lusi::IpmFexV1	_ipmFexData;
};
#pragma pack(pop)

/** @class BldDataIpimbV1

  Combined structure which includes Ipimb.DataV2, Ipimb.ConfigV2, and
            Lusi.IpmFexV1 objects.
*/

#pragma pack(push,4)

class BldDataIpimbV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedIpimb /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataIpimbV1() {}
  BldDataIpimbV1(const BldDataIpimbV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataIpimbV1& operator=(const BldDataIpimbV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  const Ipimb::DataV2& ipimbData() const { return _ipimbData; }
  const Ipimb::ConfigV2& ipimbConfig() const { return _ipimbConfig; }
  const Lusi::IpmFexV1& ipmFexData() const { return _ipmFexData; }
  static uint32_t _sizeof() { return ((((((0+(Ipimb::DataV2::_sizeof()))+(Ipimb::ConfigV2::_sizeof()))+(Lusi::IpmFexV1::_sizeof()))+4)-1)/4)*4; }
private:
  Ipimb::DataV2	_ipimbData;
  Ipimb::ConfigV2	_ipimbConfig;
  Lusi::IpmFexV1	_ipmFexData;
};
#pragma pack(pop)

/** @class BldDataPimV1

  Combined structure which includes Pulnix.TM6740ConfigV2, Lusi.PimImageConfigV1, and
            Camera.FrameV1 objects.
*/

#pragma pack(push,4)

class BldDataPimV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedPim /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataPimV1() {}
  BldDataPimV1(const BldDataPimV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataPimV1& operator=(const BldDataPimV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  const Pulnix::TM6740ConfigV2& camConfig() const { return _camConfig; }
  const Lusi::PimImageConfigV1& pimConfig() const { return _pimConfig; }
  const Camera::FrameV1& frame() const { return _frame; }
  uint32_t _sizeof() const { return ((((((0+(Pulnix::TM6740ConfigV2::_sizeof()))+(Lusi::PimImageConfigV1::_sizeof()))+(this->_frame._sizeof()))+4)-1)/4)*4; }
private:
  Pulnix::TM6740ConfigV2	_camConfig;
  Lusi::PimImageConfigV1	_pimConfig;
  Camera::FrameV1	_frame;
};
#pragma pack(pop)

/** @class BldDataUsdUsbV1

  Combined structure which includes UsdUsb.ConfigV1, UsdUsb.FexConfigV1, UsdUsb.DataV1, and
            UsdUsb.FexDataV1 objects.
*/

#pragma pack(push,4)

class BldDataUsdUsbV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedUsdUsb /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataUsdUsbV1() {}
  BldDataUsdUsbV1(const BldDataUsdUsbV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataUsdUsbV1& operator=(const BldDataUsdUsbV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  const UsdUsb::ConfigV1& config() const { return _config; }
  const UsdUsb::FexConfigV1& fexConfig() const { return _fexConfig; }
  const UsdUsb::DataV1& data() const { return _data; }
  const UsdUsb::FexDataV1& fexData() const { return _fexData; }
  static uint32_t _sizeof() { return (((((((0+(UsdUsb::ConfigV1::_sizeof()))+(UsdUsb::FexConfigV1::_sizeof()))+(UsdUsb::DataV1::_sizeof()))+(UsdUsb::FexDataV1::_sizeof()))+4)-1)/4)*4; }
private:
  UsdUsb::ConfigV1	_config;
  UsdUsb::FexConfigV1	_fexConfig;
  UsdUsb::DataV1	_data;
  UsdUsb::FexDataV1	_fexData;
};
#pragma pack(pop)

/** @class BldDataGMDV0

  Gas Monitor Detector data.
*/

#pragma pack(push,4)

class BldDataGMDV0 {
public:
  enum { TypeId = Pds::TypeId::Id_GMD /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataGMDV0() {}
  BldDataGMDV0(const BldDataGMDV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataGMDV0& operator=(const BldDataGMDV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** String describing gas type */
  const char* gasType() const { return _strGasType; }
  /** Pressure from Spinning Rotor Gauge */
  double pressure() const { return _fPressure; }
  /** Temp from PT100 */
  double temperature() const { return _fTemperature; }
  /** Current from Keithley Electrometer */
  double current() const { return _fCurrent; }
  /** HV Mesh Electron */
  double hvMeshElectron() const { return _fHvMeshElectron; }
  /** HV Mesh Ion */
  double hvMeshIon() const { return _fHvMeshIon; }
  /** HV Mult Ion */
  double hvMultIon() const { return _fHvMultIon; }
  /** Charge Q */
  double chargeQ() const { return _fChargeQ; }
  /** Photon Energy */
  double photonEnergy() const { return _fPhotonEnergy; }
  /** Pulse Intensity derived from Electron Multiplier */
  double multPulseIntensity() const { return _fMultPulseIntensity; }
  /** Pulse Intensity derived from ION cup current */
  double keithleyPulseIntensity() const { return _fKeithleyPulseIntensity; }
  /** Pulse Energy derived from Electron Multiplier */
  double pulseEnergy() const { return _fPulseEnergy; }
  /** Pulse Energy from FEE Gas Detector */
  double pulseEnergyFEE() const { return _fPulseEnergyFEE; }
  /** Transmission derived from Electron Multiplier */
  double transmission() const { return _fTransmission; }
  /** Transmission from FEE Gas Detector */
  double transmissionFEE() const { return _fTransmissionFEE; }
  static uint32_t _sizeof() { return (((((((((((((((((((0+(1*(32)))+8)+8)+8)+8)+8)+8)+8)+8)+8)+8)+8)+8)+8)+8)+8)+4)-1)/4)*4; }
private:
  char	_strGasType[32];	/**< String describing gas type */
  double	_fPressure;	/**< Pressure from Spinning Rotor Gauge */
  double	_fTemperature;	/**< Temp from PT100 */
  double	_fCurrent;	/**< Current from Keithley Electrometer */
  double	_fHvMeshElectron;	/**< HV Mesh Electron */
  double	_fHvMeshIon;	/**< HV Mesh Ion */
  double	_fHvMultIon;	/**< HV Mult Ion */
  double	_fChargeQ;	/**< Charge Q */
  double	_fPhotonEnergy;	/**< Photon Energy */
  double	_fMultPulseIntensity;	/**< Pulse Intensity derived from Electron Multiplier */
  double	_fKeithleyPulseIntensity;	/**< Pulse Intensity derived from ION cup current */
  double	_fPulseEnergy;	/**< Pulse Energy derived from Electron Multiplier */
  double	_fPulseEnergyFEE;	/**< Pulse Energy from FEE Gas Detector */
  double	_fTransmission;	/**< Transmission derived from Electron Multiplier */
  double	_fTransmissionFEE;	/**< Transmission from FEE Gas Detector */
  double	_fSpare6;
};
#pragma pack(pop)

/** @class BldDataGMDV1

  Gas Monitor Detector data.
*/

#pragma pack(push,4)

class BldDataGMDV1 {
public:
  enum { TypeId = Pds::TypeId::Id_GMD /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataGMDV1() {}
  BldDataGMDV1(const BldDataGMDV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataGMDV1& operator=(const BldDataGMDV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Shot to shot pulse energy (mJ) */
  double milliJoulesPerPulse() const { return _fMilliJoulesPerPulse; }
  /** Average pulse energy from ION cup current (mJ) */
  double milliJoulesAverage() const { return _fMilliJoulesAverage; }
  /** Bg corrected waveform integrated within limits in raw A/D counts */
  double correctedSumPerPulse() const { return _fCorrectedSumPerPulse; }
  /** Avg background value per sample in raw A/D counts */
  double bgValuePerSample() const { return _fBgValuePerSample; }
  /** Shot by shot pulse energy in arbitrary units */
  double relativeEnergyPerPulse() const { return _fRelativeEnergyPerPulse; }
  static uint32_t _sizeof() { return 48; }
private:
  double	_fMilliJoulesPerPulse;	/**< Shot to shot pulse energy (mJ) */
  double	_fMilliJoulesAverage;	/**< Average pulse energy from ION cup current (mJ) */
  double	_fCorrectedSumPerPulse;	/**< Bg corrected waveform integrated within limits in raw A/D counts */
  double	_fBgValuePerSample;	/**< Avg background value per sample in raw A/D counts */
  double	_fRelativeEnergyPerPulse;	/**< Shot by shot pulse energy in arbitrary units */
  double	_fSpare1;
};
#pragma pack(pop)

/** @class BldDataGMDV2

  Gas Monitor Detector data.
*/

#pragma pack(push,4)

class BldDataGMDV2 {
public:
  enum { TypeId = Pds::TypeId::Id_GMD /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  BldDataGMDV2() {}
  BldDataGMDV2(const BldDataGMDV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataGMDV2& operator=(const BldDataGMDV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Shot to shot pulse energy (mJ).  Not as robust as relativeEnergyPerPulse() method. */
  double milliJoulesPerPulse() const { return _fMilliJoulesPerPulse; }
  /** Average pulse energy from ION cup current (mJ).  Not as robust as relativeEnergyPerPulse() method. */
  double milliJoulesAverage() const { return _fMilliJoulesAverage; }
  /** Sum of all peaks, normalized w/ filt bkgd level.  Not typically used by the user. */
  double sumAllPeaksFiltBkgd() const { return _fSumAllPeaksFiltBkgd; }
  /** Avg background value per waveform in raw A/D counts.  Not typically used by the user. */
  double rawAvgBkgd() const { return _fRawAvgBkgd; }
  /** Shot by shot pulse energy in arbitrary units.  The most stable measurement.  Most users should use this. */
  double relativeEnergyPerPulse() const { return _fRelativeEnergyPerPulse; }
  /** Sum of all peaks, normalized w/ raw avg bkgd level.  Not typically used by the user. */
  double sumAllPeaksRawBkgd() const { return _fSumAllPeaksRawBkgd; }
  static uint32_t _sizeof() { return 48; }
private:
  double	_fMilliJoulesPerPulse;	/**< Shot to shot pulse energy (mJ).  Not as robust as relativeEnergyPerPulse() method. */
  double	_fMilliJoulesAverage;	/**< Average pulse energy from ION cup current (mJ).  Not as robust as relativeEnergyPerPulse() method. */
  double	_fSumAllPeaksFiltBkgd;	/**< Sum of all peaks, normalized w/ filt bkgd level.  Not typically used by the user. */
  double	_fRawAvgBkgd;	/**< Avg background value per waveform in raw A/D counts.  Not typically used by the user. */
  double	_fRelativeEnergyPerPulse;	/**< Shot by shot pulse energy in arbitrary units.  The most stable measurement.  Most users should use this. */
  double	_fSumAllPeaksRawBkgd;	/**< Sum of all peaks, normalized w/ raw avg bkgd level.  Not typically used by the user. */
};
#pragma pack(pop)

/** @class BldDataAcqADCV1

  Combined structure which includes Acqiris.ConfigV1 and
            Acqiris.DataDescV1 objects.
*/

#pragma pack(push,4)

class BldDataAcqADCV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedAcqADC /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataAcqADCV1() {}
private:
  BldDataAcqADCV1(const BldDataAcqADCV1&);
  BldDataAcqADCV1& operator=(const BldDataAcqADCV1&);
public:
  const Acqiris::ConfigV1& config() const { return _config; }
  const Acqiris::DataDescV1& data() const { return _data; }
private:
  Acqiris::ConfigV1	_config;
  Acqiris::DataDescV1	_data;
};
#pragma pack(pop)

/** @class BldDataSpectrometerV0

  Structure which contains image projections for spectrometers.
*/

#pragma pack(push,4)

class BldDataSpectrometerV0 {
public:
  enum { TypeId = Pds::TypeId::Id_Spectrometer /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataSpectrometerV0(const uint32_t* arg__hproj, const uint32_t* arg__vproj)
  {
    if (arg__hproj) std::copy(arg__hproj, arg__hproj+(1024), &_hproj[0]);
    if (arg__vproj) std::copy(arg__vproj, arg__vproj+(256), &_vproj[0]);
  }
  BldDataSpectrometerV0() {}
  BldDataSpectrometerV0(const BldDataSpectrometerV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataSpectrometerV0& operator=(const BldDataSpectrometerV0& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> hproj(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_hproj[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), 1024);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> hproj() const { return make_ndarray(&_hproj[0], 1024); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> vproj(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_vproj[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), 256);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> vproj() const { return make_ndarray(&_vproj[0], 256); }
  static uint32_t _sizeof() { return (((((0+(4*(1024)))+(4*(256)))+4)-1)/4)*4; }
private:
  uint32_t	_hproj[1024];
  uint32_t	_vproj[256];
};
#pragma pack(pop)

/** @class BldDataSpectrometerV1

  Structure which contains image projections and fit parameters for spectrometers. 
    Changes from V0 include extending size of hproj, removal of vproj,
     and addition of fit parameters.
*/

#pragma pack(push,4)

class BldDataSpectrometerV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Spectrometer /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataSpectrometerV1(uint32_t arg__width, uint32_t arg__hproj_y1, uint32_t arg__hproj_y2, double arg__fComRaw, double arg__fBaseline, double arg__fCom, double arg__fIntegral, uint32_t arg__nPeaks, const int32_t* arg__hproj, const double* arg__peakPos, const double* arg__peakHeight, const double* arg__Fwhm);
  BldDataSpectrometerV1(uint32_t width, uint32_t nPeaks)
    : _width(width), _nPeaks(nPeaks)
  {
  }
  BldDataSpectrometerV1() {}
  BldDataSpectrometerV1(const BldDataSpectrometerV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataSpectrometerV1& operator=(const BldDataSpectrometerV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Width of camera frame and thus size of hproj array 
     PV TBD */
  uint32_t width() const { return _width; }
  /** First row of pixels used in projection ROI  
     PV TBD */
  uint32_t hproj_y1() const { return _hproj_y1; }
  /** Last row of pixels used in projection ROI
    PV: TBD */
  uint32_t hproj_y2() const { return _hproj_y2; }
  /** Raw center of mass, no baseline subtraction 
     PV: TBD */
  double comRaw() const { return _fComRaw; }
  /** Baseline level for calculated values 
     PV: TBD */
  double baseline() const { return _fBaseline; }
  /** Baseline-subtracted center of mass 
     PV: TBD */
  double com() const { return _fCom; }
  /** Integrated area under spectrum (no baseline subtraction) 
     PV: TBD */
  double integral() const { return _fIntegral; }
  /** Number of peak fits performed
    PV: TBD */
  uint32_t nPeaks() const { return _nPeaks; }
  /** Projection of spectrum onto energy axis 
     PV TBD

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const int32_t, 1> hproj(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=48;
    const int32_t* data = (const int32_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const int32_t>(owner, data), this->_width);
  }
  /** Projection of spectrum onto energy axis 
     PV TBD

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const int32_t, 1> hproj() const { ptrdiff_t offset=48;
  const int32_t* data = (const int32_t*)(((char*)this)+offset);
  return make_ndarray(data, this->_width); }
  /** Peak position array, length given by nPeaks
     PV: TBD

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> peakPos(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=48+(4*(this->_width));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_nPeaks);
  }
  /** Peak position array, length given by nPeaks
     PV: TBD

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> peakPos() const { ptrdiff_t offset=48+(4*(this->_width));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_nPeaks); }
  /** Peak height array, length given by nPeaks
     PV: TBD

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> peakHeight(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(48+(4*(this->_width)))+(8*(this->_nPeaks));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_nPeaks);
  }
  /** Peak height array, length given by nPeaks
     PV: TBD

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> peakHeight() const { ptrdiff_t offset=(48+(4*(this->_width)))+(8*(this->_nPeaks));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_nPeaks); }
  /** Peak FWHM array, length given by nPeaks
     PV: TBD

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> FWHM(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((48+(4*(this->_width)))+(8*(this->_nPeaks)))+(8*(this->_nPeaks));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_nPeaks);
  }
  /** Peak FWHM array, length given by nPeaks
     PV: TBD

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> FWHM() const { ptrdiff_t offset=((48+(4*(this->_width)))+(8*(this->_nPeaks)))+(8*(this->_nPeaks));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_nPeaks); }
  uint32_t _sizeof() const { return (((((((48+(4*(this->_width)))+(8*(this->_nPeaks)))+(8*(this->_nPeaks)))+(8*(this->_nPeaks)))+4)-1)/4)*4; }
private:
  uint32_t	_width;	/**< Width of camera frame and thus size of hproj array 
     PV TBD */
  uint32_t	_hproj_y1;	/**< First row of pixels used in projection ROI  
     PV TBD */
  uint32_t	_hproj_y2;	/**< Last row of pixels used in projection ROI
    PV: TBD */
  double	_fComRaw;	/**< Raw center of mass, no baseline subtraction 
     PV: TBD */
  double	_fBaseline;	/**< Baseline level for calculated values 
     PV: TBD */
  double	_fCom;	/**< Baseline-subtracted center of mass 
     PV: TBD */
  double	_fIntegral;	/**< Integrated area under spectrum (no baseline subtraction) 
     PV: TBD */
  uint32_t	_nPeaks;	/**< Number of peak fits performed
    PV: TBD */
  //int32_t	_hproj[this->_width];
  //double	_peakPos[this->_nPeaks];
  //double	_peakHeight[this->_nPeaks];
  //double	_Fwhm[this->_nPeaks];
};
#pragma pack(pop)

/** @class BldDataAnalogInputV1

  Structure which contains voltage data from an analog input device.
*/

#pragma pack(push,4)

class BldDataAnalogInputV1 {
public:
  enum { TypeId = Pds::TypeId::Id_AnalogInput /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataAnalogInputV1(uint32_t arg__numChannels, const double* arg__channelVoltages)
    : _numChannels(arg__numChannels)
  {
    if (arg__channelVoltages and (this->_numChannels)) {
      ptrdiff_t offset = 4;
      double* data = reinterpret_cast<double*>(((char*)this)+offset);
      std::copy(arg__channelVoltages, arg__channelVoltages+(this->_numChannels), data);
    }
  }
  BldDataAnalogInputV1() {}
  BldDataAnalogInputV1(const BldDataAnalogInputV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataAnalogInputV1& operator=(const BldDataAnalogInputV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** The number of active channels on the analog input device. */
  uint32_t numChannels() const { return _numChannels; }
  /** Array of voltage values were each entry represents a channel of the analog input device.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> channelVoltages(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->_numChannels);
  }
  /** Array of voltage values were each entry represents a channel of the analog input device.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> channelVoltages() const { ptrdiff_t offset=4;
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->_numChannels); }
  uint32_t _sizeof() const { return ((((4+(8*(this->_numChannels)))+4)-1)/4)*4; }
private:
  uint32_t	_numChannels;	/**< The number of active channels on the analog input device. */
  //double	_channelVoltages[this->_numChannels];
};
#pragma pack(pop)

/** @class BldDataBeamMonitorV1

  Intensity and Position Measurements
*/

#pragma pack(push,4)

class BldDataBeamMonitorV1 {
public:
  enum { TypeId = Pds::TypeId::Id_BeamMonitorBldData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 16 };
  BldDataBeamMonitorV1(double arg__TotalIntensity, double arg__X_Position, double arg__Y_Position, const double* arg__peakA, const uint16_t* arg__peakT)
    : _TotalIntensity(arg__TotalIntensity), _X_Position(arg__X_Position), _Y_Position(arg__Y_Position)
  {
    if (arg__peakA) std::copy(arg__peakA, arg__peakA+(16), &_peakA[0]);
    if (arg__peakT) std::copy(arg__peakT, arg__peakT+(16), &_peakT[0]);
  }
  BldDataBeamMonitorV1() {}
  BldDataBeamMonitorV1(const BldDataBeamMonitorV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  BldDataBeamMonitorV1& operator=(const BldDataBeamMonitorV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Value of Total Intensity, in J. */
  double TotalIntensity() const { return _TotalIntensity; }
  /** Value of X Position, in m. */
  double X_Position() const { return _X_Position; }
  /** Value of Y Position, in m. */
  double Y_Position() const { return _Y_Position; }
  /** Peak Amplitude of Channel

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> peakA(const boost::shared_ptr<T>& owner) const { 
    const double* data = &_peakA[0];
    return make_ndarray(boost::shared_ptr<const double>(owner, data), NCHANNELS);
  }
  /** Peak Amplitude of Channel

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> peakA() const { return make_ndarray(&_peakA[0], NCHANNELS); }
  /** Location of Peak Amplitude of Channel

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> peakT(const boost::shared_ptr<T>& owner) const { 
    const uint16_t* data = &_peakT[0];
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), NCHANNELS);
  }
  /** Location of Peak Amplitude of Channel

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> peakT() const { return make_ndarray(&_peakT[0], NCHANNELS); }
  static uint32_t _sizeof() { return (((((24+(8*(NCHANNELS)))+(2*(NCHANNELS)))+4)-1)/4)*4; }
private:
  double	_TotalIntensity;	/**< Value of Total Intensity, in J. */
  double	_X_Position;	/**< Value of X Position, in m. */
  double	_Y_Position;	/**< Value of Y Position, in m. */
  double	_peakA[NCHANNELS];	/**< Peak Amplitude of Channel */
  uint16_t	_peakT[NCHANNELS];	/**< Location of Peak Amplitude of Channel */
};
#pragma pack(pop)
} // namespace Bld
} // namespace Pds
#endif // PDS_BLD_DDL_H
