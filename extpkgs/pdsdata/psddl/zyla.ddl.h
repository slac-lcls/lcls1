#ifndef PDS_ZYLA_DDL_H
#define PDS_ZYLA_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/psddl/istar.ddl.h"
namespace Pds {
namespace Zyla {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_ZylaConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { STR_LEN_MAX = 64 };
  enum ATBool {
    False = 0,
    True = 1,
  };
  enum ShutteringMode {
    Rolling = 0,
    Global = 1,
  };
  enum FanSpeed {
    Off = 0,
    Low = 1,
    On = 2,
  };
  enum ReadoutRate {
    Rate280MHz = 0,
    Rate200MHz = 1,
    Rate100MHz = 2,
    Rate10MHz = 3,
  };
  enum TriggerMode {
    Internal = 0,
    ExternalLevelTransition = 1,
    ExternalStart = 2,
    ExternalExposure = 3,
    Software = 4,
    Advanced = 5,
    External = 6,
  };
  enum GainMode {
    HighWellCap12Bit = 0,
    LowNoise12Bit = 1,
    LowNoiseHighWellCap16Bit = 2,
  };
  enum CoolingSetpoint {
    Temp_0C = 0,
    Temp_Neg5C = 1,
    Temp_Neg10C = 2,
    Temp_Neg15C = 3,
    Temp_Neg20C = 4,
    Temp_Neg25C = 5,
    Temp_Neg30C = 6,
    Temp_Neg35C = 7,
    Temp_Neg40C = 8,
  };
  ConfigV1(Zyla::ConfigV1::ATBool arg__cooling, Zyla::ConfigV1::ATBool arg__overlap, Zyla::ConfigV1::ATBool arg__noiseFilter, Zyla::ConfigV1::ATBool arg__blemishCorrection, Zyla::ConfigV1::ShutteringMode arg__shutter, Zyla::ConfigV1::FanSpeed arg__fanSpeed, Zyla::ConfigV1::ReadoutRate arg__readoutRate, Zyla::ConfigV1::TriggerMode arg__triggerMode, Zyla::ConfigV1::GainMode arg__gainMode, Zyla::ConfigV1::CoolingSetpoint arg__setpoint, uint32_t arg__width, uint32_t arg__height, uint32_t arg__orgX, uint32_t arg__orgY, uint32_t arg__binX, uint32_t arg__binY, double arg__exposureTime, double arg__triggerDelay)
    : _cooling(arg__cooling), _overlap(arg__overlap), _noiseFilter(arg__noiseFilter), _blemishCorrection(arg__blemishCorrection), _shutter(arg__shutter), _fanSpeed(arg__fanSpeed), _readoutRate(arg__readoutRate), _triggerMode(arg__triggerMode), _gainMode(arg__gainMode), _setpoint(arg__setpoint), _width(arg__width), _height(arg__height), _orgX(arg__orgX), _orgY(arg__orgY), _binX(arg__binX), _binY(arg__binY), _exposureTime(arg__exposureTime), _triggerDelay(arg__triggerDelay)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  Zyla::ConfigV1::ATBool cooling() const { return Zyla::ConfigV1::ATBool(_cooling); }
  Zyla::ConfigV1::ATBool overlap() const { return Zyla::ConfigV1::ATBool(_overlap); }
  Zyla::ConfigV1::ATBool noiseFilter() const { return Zyla::ConfigV1::ATBool(_noiseFilter); }
  Zyla::ConfigV1::ATBool blemishCorrection() const { return Zyla::ConfigV1::ATBool(_blemishCorrection); }
  Zyla::ConfigV1::ShutteringMode shutter() const { return Zyla::ConfigV1::ShutteringMode(_shutter); }
  Zyla::ConfigV1::FanSpeed fanSpeed() const { return Zyla::ConfigV1::FanSpeed(_fanSpeed); }
  Zyla::ConfigV1::ReadoutRate readoutRate() const { return Zyla::ConfigV1::ReadoutRate(_readoutRate); }
  Zyla::ConfigV1::TriggerMode triggerMode() const { return Zyla::ConfigV1::TriggerMode(_triggerMode); }
  Zyla::ConfigV1::GainMode gainMode() const { return Zyla::ConfigV1::GainMode(_gainMode); }
  Zyla::ConfigV1::CoolingSetpoint setpoint() const { return Zyla::ConfigV1::CoolingSetpoint(_setpoint); }
  uint32_t width() const { return _width; }
  uint32_t height() const { return _height; }
  uint32_t orgX() const { return _orgX; }
  uint32_t orgY() const { return _orgY; }
  uint32_t binX() const { return _binX; }
  uint32_t binY() const { return _binY; }
  double exposureTime() const { return _exposureTime; }
  double triggerDelay() const { return _triggerDelay; }
  /** Total size in bytes of the Frame object */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (width() + binX() - 1) / binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (height() + binY() - 1) / binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return numPixelsX()*numPixelsY(); }
  static uint32_t _sizeof() { return 52; }
private:
  uint8_t	_cooling;
  uint8_t	_overlap;
  uint8_t	_noiseFilter;
  uint8_t	_blemishCorrection;
  uint8_t	_shutter;
  uint8_t	_fanSpeed;
  uint8_t	_readoutRate;
  uint8_t	_triggerMode;
  uint8_t	_gainMode;
  uint8_t	_setpoint;
  uint16_t	_pad0;
  uint32_t	_width;
  uint32_t	_height;
  uint32_t	_orgX;
  uint32_t	_orgY;
  uint32_t	_binX;
  uint32_t	_binY;
  double	_exposureTime;
  double	_triggerDelay;
};
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::ATBool enval);
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::ShutteringMode enval);
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::FanSpeed enval);
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::ReadoutRate enval);
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::TriggerMode enval);
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::GainMode enval);
std::ostream& operator<<(std::ostream& str, Zyla::ConfigV1::CoolingSetpoint enval);
#pragma pack(pop)

/** @class FrameV1

  
*/

class ConfigV1;
#pragma pack(push,2)

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_ZylaFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  FrameV1(uint64_t timestamp)
    : _timestamp(timestamp)
  {
  }
  FrameV1() {}
private:
  FrameV1(const FrameV1&);
  FrameV1& operator=(const FrameV1&);
public:
  /** The internal camera FPGA clock timestamp for the frame. */
  uint64_t timestamp() const { return _timestamp; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> data(const Zyla::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=8;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numPixelsY(), cfg.numPixelsX());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> data(const iStar::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=8;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numPixelsY(), cfg.numPixelsX());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> data(const Zyla::ConfigV1& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> data(const iStar::ConfigV1& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  static uint32_t _sizeof(const Zyla::ConfigV1& cfg) { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+2)-1)/2)*2; }
  static uint32_t _sizeof(const iStar::ConfigV1& cfg) { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+2)-1)/2)*2; }
private:
  uint64_t	_timestamp;	/**< The internal camera FPGA clock timestamp for the frame. */
  //uint16_t	_data[cfg.numPixelsY()][cfg.numPixelsX()];
};
#pragma pack(pop)
} // namespace Zyla
} // namespace Pds
#endif // PDS_ZYLA_DDL_H
