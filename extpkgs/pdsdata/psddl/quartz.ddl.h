#ifndef PDS_QUARTZ_DDL_H
#define PDS_QUARTZ_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/psddl/camera.ddl.h"
namespace Pds {
namespace Quartz {

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_QuartzConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { LUT_Size = 4096 };
  enum { Row_Pixels = 2048 };
  enum { Column_Pixels = 2048 };
  enum { Output_LUT_Size = 4096 };

  /** Image bit depth modes. */
  enum Depth {
    Eight_bit,
    Ten_bit,
  };
  enum Binning {
    x1,
    x2,
    x4,
  };
  enum Mirroring {
    None,
    HFlip,
    VFlip,
    HVFlip,
  };
  ConfigV1(uint16_t arg__bf_offset, uint16_t arg__bf_gain, Quartz::ConfigV1::Depth arg__bf_resol, Quartz::ConfigV1::Binning arg__bf_hbin, Quartz::ConfigV1::Binning arg__bf_vbin, Quartz::ConfigV1::Mirroring arg__bf_mirr, uint8_t arg__bf_lookup, uint8_t arg__bf_corr, uint32_t arg__defectPixelCount, const uint16_t* arg__lookup_table, const Camera::FrameCoord* arg__defectPixels)
    : _offsetAndGain(((arg__bf_offset) & 0xffff)|(((arg__bf_gain) & 0xffff)<<16)), _outputOptions(((arg__bf_resol) & 0xf)|(((arg__bf_hbin) & 0x3)<<4)|(((arg__bf_vbin) & 0x3)<<6)|(((arg__bf_mirr) & 0xf)<<8)|(((arg__bf_lookup) & 0x1)<<12)|(((arg__bf_corr) & 0x1)<<13)), _defectPixelCount(arg__defectPixelCount)
  {
    if (arg__lookup_table and (Output_LUT_Size*this->output_lookup_table_enabled())) {
      ptrdiff_t offset = 12;
      uint16_t* data = reinterpret_cast<uint16_t*>(((char*)this)+offset);
      std::copy(arg__lookup_table, arg__lookup_table+(Output_LUT_Size*this->output_lookup_table_enabled()), data);
    }
    if (arg__defectPixels and (this->number_of_defect_pixels())) {
      ptrdiff_t offset = 12+(2*(Output_LUT_Size*this->output_lookup_table_enabled()));
      Camera::FrameCoord* data = reinterpret_cast<Camera::FrameCoord*>(((char*)this)+offset);
      std::copy(arg__defectPixels, arg__defectPixels+(this->number_of_defect_pixels()), data);
    }
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** offset/pedestal setting for camera (before gain) */
  uint16_t black_level() const { return uint16_t(this->_offsetAndGain & 0xffff); }
  /** camera gain setting in percentile [100-3200] = [1x-32x] */
  uint16_t gain_percent() const { return uint16_t((this->_offsetAndGain>>16) & 0xffff); }
  /** bit-depth of pixel counts */
  Quartz::ConfigV1::Depth output_resolution() const { return Depth(this->_outputOptions & 0xf); }
  /** horizontal re-binning of output (consecutive rows summed) */
  Quartz::ConfigV1::Binning horizontal_binning() const { return Binning((this->_outputOptions>>4) & 0x3); }
  /** vertical re-binning of output (consecutive rows summed) */
  Quartz::ConfigV1::Binning vertical_binning() const { return Binning((this->_outputOptions>>6) & 0x3); }
  /** geometric transformation of the image */
  Quartz::ConfigV1::Mirroring output_mirroring() const { return Mirroring((this->_outputOptions>>8) & 0xf); }
  /** apply output lookup table corrections */
  uint8_t output_lookup_table_enabled() const { return uint8_t((this->_outputOptions>>12) & 0x1); }
  /** correct defective pixels internally */
  uint8_t defect_pixel_correction_enabled() const { return uint8_t((this->_outputOptions>>13) & 0x1); }
  uint32_t number_of_defect_pixels() const { return _defectPixelCount; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> output_lookup_table(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=12;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), Output_LUT_Size*this->output_lookup_table_enabled());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> output_lookup_table() const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, Output_LUT_Size*this->output_lookup_table_enabled()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const Camera::FrameCoord, 1> defect_pixel_coordinates(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=12+(2*(Output_LUT_Size*this->output_lookup_table_enabled()));
    const Camera::FrameCoord* data = (const Camera::FrameCoord*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const Camera::FrameCoord>(owner, data), this->number_of_defect_pixels());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const Camera::FrameCoord, 1> defect_pixel_coordinates() const { ptrdiff_t offset=12+(2*(Output_LUT_Size*this->output_lookup_table_enabled()));
  const Camera::FrameCoord* data = (const Camera::FrameCoord*)(((char*)this)+offset);
  return make_ndarray(data, this->number_of_defect_pixels()); }
  /** offset/pedestal value in pixel counts */
  uint16_t output_offset() const;
  /** bit-depth of pixel counts */
  uint32_t output_resolution_bits() const;
  uint32_t _sizeof() const { return (((((12+(2*(Output_LUT_Size*this->output_lookup_table_enabled())))+(Camera::FrameCoord::_sizeof()*(this->number_of_defect_pixels())))+4)-1)/4)*4; }
private:
  uint32_t	_offsetAndGain;	/**< offset and gain */
  uint32_t	_outputOptions;	/**< bit mask of output formatting options */
  uint32_t	_defectPixelCount;
  //uint16_t	_lookup_table[Output_LUT_Size*this->output_lookup_table_enabled()];
  //Camera::FrameCoord	_defectPixels[this->number_of_defect_pixels()];
};
std::ostream& operator<<(std::ostream& str, Quartz::ConfigV1::Depth enval);
std::ostream& operator<<(std::ostream& str, Quartz::ConfigV1::Binning enval);
std::ostream& operator<<(std::ostream& str, Quartz::ConfigV1::Mirroring enval);

/** @class ConfigV2

  
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_QuartzConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { LUT_Size = 4096 };
  enum { Row_Pixels = 2048 };
  enum { Column_Pixels = 2048 };
  enum { Output_LUT_Size = 4096 };

  /** Image bit depth modes. */
  enum Depth {
    Eight_bit,
    Ten_bit,
  };
  enum Binning {
    x1,
    x2,
    x4,
  };
  enum Mirroring {
    None,
    HFlip,
    VFlip,
    HVFlip,
  };
  ConfigV2(uint16_t arg__bf_offset, uint16_t arg__bf_gain, Quartz::ConfigV2::Depth arg__bf_resol, Quartz::ConfigV2::Binning arg__bf_hbin, Quartz::ConfigV2::Binning arg__bf_vbin, Quartz::ConfigV2::Mirroring arg__bf_mirr, uint8_t arg__bf_lookup, uint8_t arg__bf_corr, uint8_t arg__use_roi, uint8_t arg__use_test_pattern, uint8_t arg__max_taps, const Camera::FrameCoord& arg__roi_lo, const Camera::FrameCoord& arg__roi_hi, uint32_t arg__defectPixelCount, const uint16_t* arg__lookup_table, const Camera::FrameCoord* arg__defectPixels)
    : _offsetAndGain(((arg__bf_offset) & 0xffff)|(((arg__bf_gain) & 0xffff)<<16)), _outputOptions(((arg__bf_resol) & 0xf)|(((arg__bf_hbin) & 0x3)<<4)|(((arg__bf_vbin) & 0x3)<<6)|(((arg__bf_mirr) & 0xf)<<8)|(((arg__bf_lookup) & 0x1)<<12)|(((arg__bf_corr) & 0x1)<<13)|(((arg__use_roi) & 0x1)<<14)|(((arg__use_test_pattern) & 0x1)<<15)|(((arg__max_taps) & 0xf)<<16)), _roi_lo(arg__roi_lo), _roi_hi(arg__roi_hi), _defectPixelCount(arg__defectPixelCount)
  {
    if (arg__lookup_table and (Output_LUT_Size*this->output_lookup_table_enabled())) {
      ptrdiff_t offset = 20;
      uint16_t* data = reinterpret_cast<uint16_t*>(((char*)this)+offset);
      std::copy(arg__lookup_table, arg__lookup_table+(Output_LUT_Size*this->output_lookup_table_enabled()), data);
    }
    if (arg__defectPixels and (this->number_of_defect_pixels())) {
      ptrdiff_t offset = 20+(2*(Output_LUT_Size*this->output_lookup_table_enabled()));
      Camera::FrameCoord* data = reinterpret_cast<Camera::FrameCoord*>(((char*)this)+offset);
      std::copy(arg__defectPixels, arg__defectPixels+(this->number_of_defect_pixels()), data);
    }
  }
  ConfigV2() {}
  ConfigV2(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV2& operator=(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** offset/pedestal setting for camera (before gain) */
  uint16_t black_level() const { return uint16_t(this->_offsetAndGain & 0xffff); }
  /** camera gain setting in percentile [100-3200] = [1x-32x] */
  uint16_t gain_percent() const { return uint16_t((this->_offsetAndGain>>16) & 0xffff); }
  /** bit-depth of pixel counts */
  Quartz::ConfigV2::Depth output_resolution() const { return Depth(this->_outputOptions & 0xf); }
  /** horizontal re-binning of output (consecutive rows summed) */
  Quartz::ConfigV2::Binning horizontal_binning() const { return Binning((this->_outputOptions>>4) & 0x3); }
  /** vertical re-binning of output (consecutive rows summed) */
  Quartz::ConfigV2::Binning vertical_binning() const { return Binning((this->_outputOptions>>6) & 0x3); }
  /** geometric transformation of the image */
  Quartz::ConfigV2::Mirroring output_mirroring() const { return Mirroring((this->_outputOptions>>8) & 0xf); }
  /** apply output lookup table corrections */
  uint8_t output_lookup_table_enabled() const { return uint8_t((this->_outputOptions>>12) & 0x1); }
  /** correct defective pixels internally */
  uint8_t defect_pixel_correction_enabled() const { return uint8_t((this->_outputOptions>>13) & 0x1); }
  /** enable hardware region of interest */
  uint8_t use_hardware_roi() const { return uint8_t((this->_outputOptions>>14) & 0x1); }
  /** enable the test pattern */
  uint8_t use_test_pattern() const { return uint8_t((this->_outputOptions>>15) & 0x1); }
  /** maximum taps in output driver */
  uint8_t max_taps() const { return uint8_t((this->_outputOptions>>16) & 0xf); }
  /** hardware ROI begin */
  const Camera::FrameCoord& roi_lo() const { return _roi_lo; }
  /** hardware ROI end */
  const Camera::FrameCoord& roi_hi() const { return _roi_hi; }
  uint32_t number_of_defect_pixels() const { return _defectPixelCount; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> output_lookup_table(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=20;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), Output_LUT_Size*this->output_lookup_table_enabled());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> output_lookup_table() const { ptrdiff_t offset=20;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, Output_LUT_Size*this->output_lookup_table_enabled()); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const Camera::FrameCoord, 1> defect_pixel_coordinates(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=20+(2*(Output_LUT_Size*this->output_lookup_table_enabled()));
    const Camera::FrameCoord* data = (const Camera::FrameCoord*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const Camera::FrameCoord>(owner, data), this->number_of_defect_pixels());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const Camera::FrameCoord, 1> defect_pixel_coordinates() const { ptrdiff_t offset=20+(2*(Output_LUT_Size*this->output_lookup_table_enabled()));
  const Camera::FrameCoord* data = (const Camera::FrameCoord*)(((char*)this)+offset);
  return make_ndarray(data, this->number_of_defect_pixels()); }
  /** offset/pedestal value in pixel counts */
  uint16_t output_offset() const;
  /** bit-depth of pixel counts */
  uint32_t output_resolution_bits() const;
  uint32_t _sizeof() const { return ((((((((8+(Camera::FrameCoord::_sizeof()))+(Camera::FrameCoord::_sizeof()))+4)+(2*(Output_LUT_Size*this->output_lookup_table_enabled())))+(Camera::FrameCoord::_sizeof()*(this->number_of_defect_pixels())))+4)-1)/4)*4; }
private:
  uint32_t	_offsetAndGain;	/**< offset and gain */
  uint32_t	_outputOptions;	/**< bit mask of output formatting options */
  Camera::FrameCoord	_roi_lo;	/**< hardware ROI begin */
  Camera::FrameCoord	_roi_hi;	/**< hardware ROI end */
  uint32_t	_defectPixelCount;
  //uint16_t	_lookup_table[Output_LUT_Size*this->output_lookup_table_enabled()];
  //Camera::FrameCoord	_defectPixels[this->number_of_defect_pixels()];
};
std::ostream& operator<<(std::ostream& str, Quartz::ConfigV2::Depth enval);
std::ostream& operator<<(std::ostream& str, Quartz::ConfigV2::Binning enval);
std::ostream& operator<<(std::ostream& str, Quartz::ConfigV2::Mirroring enval);
} // namespace Quartz
} // namespace Pds
#endif // PDS_QUARTZ_DDL_H
