#ifndef PDS_UXI_DDL_H
#define PDS_UXI_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Uxi {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UxiConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NumberOfPots = 13 /**< Defines the number of potentiometers in the Icarus detector. */ };
  enum { NumberOfSides = 2 };
  ConfigV1(uint32_t arg__width, uint32_t arg__height, uint32_t arg__numberOfFrames, uint32_t arg__numberOfBytesPerPixel, uint32_t arg__sensorType, const uint32_t* arg__timeOn, const uint32_t* arg__timeOff, const uint32_t* arg__delay, uint32_t arg__readOnlyPots, const double* arg__pots);
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** The width in pixels of each frame of the detector. */
  uint32_t width() const { return _width; }
  /** The height in pixels of each frame of the detector. */
  uint32_t height() const { return _height; }
  /** The number of frames produced by the detector. */
  uint32_t numberOfFrames() const { return _numberOfFrames; }
  /** The number of bytes for each pixel. */
  uint32_t numberOFBytesPerPixel() const { return _numberOfBytesPerPixel; }
  /** The sensor type ID. */
  uint32_t sensorType() const { return _sensorType; }
  /** High speed timing on parameter in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> timeOn(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_timeOn[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing on parameter in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> timeOn() const { return make_ndarray(&_timeOn[0], NumberOfSides); }
  /** High speed timing off parameter in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> timeOff(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_timeOff[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing off parameter in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> timeOff() const { return make_ndarray(&_timeOff[0], NumberOfSides); }
  /** High speed timing initial delay in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> delay(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_delay[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing initial delay in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> delay() const { return make_ndarray(&_delay[0], NumberOfSides); }
  /** Bitmask to designate which pots should only be read and not written. */
  uint32_t readOnlyPots() const { return _readOnlyPots; }
  /** The values of the each of the pots in volts.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> pots(const boost::shared_ptr<T>& owner) const { 
    const double* data = &_pots[0];
    return make_ndarray(boost::shared_ptr<const double>(owner, data), NumberOfPots);
  }
  /** The values of the each of the pots in volts.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> pots() const { return make_ndarray(&_pots[0], NumberOfPots); }
  /** Check if a pot is readonly. */
  uint8_t potIsReadOnly(uint8_t i) const { return ((i<NumberOfPots) && (_readOnlyPots & (1<<i))) ? 1 : 0; }
  /** Check if a pot was tuned. */
  uint8_t potIsTuned(uint8_t i) const { return ((i<NumberOfPots) && (_readOnlyPots & (1<<(i+NumberOfPots)))) ? 1 : 0; }
  /** calculate total number of pixels per frame. */
  uint32_t numPixelsPerFrame() const { return this->width()*this->height(); }
  /** calculate total number of pixels across all frames. */
  uint32_t numPixels() const { return this->width()*this->height()*this->numberOfFrames(); }
  /** Total size in bytes of the frame */
  uint32_t frameSize() const;
  static uint32_t _sizeof() { return ((((((((20+(4*(NumberOfSides)))+(4*(NumberOfSides)))+(4*(NumberOfSides)))+4)+(8*(NumberOfPots)))+4)-1)/4)*4; }
private:
  uint32_t	_width;	/**< The width in pixels of each frame of the detector. */
  uint32_t	_height;	/**< The height in pixels of each frame of the detector. */
  uint32_t	_numberOfFrames;	/**< The number of frames produced by the detector. */
  uint32_t	_numberOfBytesPerPixel;	/**< The number of bytes for each pixel. */
  uint32_t	_sensorType;	/**< The sensor type ID. */
  uint32_t	_timeOn[NumberOfSides];	/**< High speed timing on parameter in ns for each side. */
  uint32_t	_timeOff[NumberOfSides];	/**< High speed timing off parameter in ns for each side. */
  uint32_t	_delay[NumberOfSides];	/**< High speed timing initial delay in ns for each side. */
  uint32_t	_readOnlyPots;	/**< Bitmask to designate which pots should only be read and not written. */
  double	_pots[NumberOfPots];	/**< The values of the each of the pots in volts. */
};
#pragma pack(pop)

/** @class RoiCoord

  
*/


class RoiCoord {
public:
  RoiCoord(uint16_t arg__first, uint16_t arg__last)
    : _first(arg__first), _last(arg__last)
  {
  }
  RoiCoord() {}
  /** The first row/frame of ROI. */
  uint16_t first() const { return _first; }
  /** The last row/frame of ROI. */
  uint16_t last() const { return _last; }
  static uint32_t _sizeof() { return 4; }
private:
  uint16_t	_first;	/**< The first row/frame of ROI. */
  uint16_t	_last;	/**< The last row/frame of ROI. */
};

/** @class ConfigV2

  
*/

#pragma pack(push,4)

class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_UxiConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { NumberOfPots = 13 /**< Defines the number of potentiometers in the Icarus detector. */ };
  enum { NumberOfSides = 2 };
  enum RoiMode {
    Off = 0,
    On = 1,
  };
  ConfigV2(Uxi::ConfigV2::RoiMode arg__roiEnable, const Uxi::RoiCoord& arg__roiRows, const Uxi::RoiCoord& arg__roiFrames, uint32_t arg__width, uint32_t arg__height, uint32_t arg__numberOfFrames, uint32_t arg__numberOfBytesPerPixel, uint32_t arg__sensorType, const uint32_t* arg__timeOn, const uint32_t* arg__timeOff, const uint32_t* arg__delay, uint32_t arg__readOnlyPots, const double* arg__pots);
  ConfigV2() {}
  ConfigV2(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV2& operator=(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Enable frame/row roi. */
  Uxi::ConfigV2::RoiMode roiEnable() const { return Uxi::ConfigV2::RoiMode(_roiEnable); }
  /** The first/last rows of the roi. */
  const Uxi::RoiCoord& roiRows() const { return _roiRows; }
  /** The first/last frames of the roi. */
  const Uxi::RoiCoord& roiFrames() const { return _roiFrames; }
  /** The width in pixels of each frame of the detector. */
  uint32_t width() const { return _width; }
  /** The height in pixels of each frame of the detector. */
  uint32_t height() const { return _height; }
  /** The number of frames produced by the detector. */
  uint32_t numberOfFrames() const { return _numberOfFrames; }
  /** The number of bytes for each pixel. */
  uint32_t numberOFBytesPerPixel() const { return _numberOfBytesPerPixel; }
  /** The sensor type ID. */
  uint32_t sensorType() const { return _sensorType; }
  /** High speed timing on parameter in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> timeOn(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_timeOn[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing on parameter in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> timeOn() const { return make_ndarray(&_timeOn[0], NumberOfSides); }
  /** High speed timing off parameter in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> timeOff(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_timeOff[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing off parameter in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> timeOff() const { return make_ndarray(&_timeOff[0], NumberOfSides); }
  /** High speed timing initial delay in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> delay(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_delay[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing initial delay in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> delay() const { return make_ndarray(&_delay[0], NumberOfSides); }
  /** Bitmask to designate which pots should only be read and not written. */
  uint32_t readOnlyPots() const { return _readOnlyPots; }
  /** The values of the each of the pots in volts.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> pots(const boost::shared_ptr<T>& owner) const { 
    const double* data = &_pots[0];
    return make_ndarray(boost::shared_ptr<const double>(owner, data), NumberOfPots);
  }
  /** The values of the each of the pots in volts.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> pots() const { return make_ndarray(&_pots[0], NumberOfPots); }
  /** Check if a pot is readonly. */
  uint8_t potIsReadOnly(uint8_t i) const { return ((i<NumberOfPots) && (_readOnlyPots & (1<<i))) ? 1 : 0; }
  /** Check if a pot was tuned. */
  uint8_t potIsTuned(uint8_t i) const { return ((i<NumberOfPots) && (_readOnlyPots & (1<<(i+NumberOfPots)))) ? 1 : 0; }
  /** calculate total number of pixels per frame. */
  uint32_t numPixelsPerFrame() const { return this->width()*this->height(); }
  /** calculate total number of pixels across all frames. */
  uint32_t numPixels() const { return this->width()*this->height()*this->numberOfFrames(); }
  /** Total size in bytes of the frame */
  uint32_t frameSize() const;
  static uint32_t _sizeof() { return (((((((((((((((4+(Uxi::RoiCoord::_sizeof()))+(Uxi::RoiCoord::_sizeof()))+4)+4)+4)+4)+4)+(4*(NumberOfSides)))+(4*(NumberOfSides)))+(4*(NumberOfSides)))+4)+(8*(NumberOfPots)))+4)-1)/4)*4; }
private:
  uint32_t	_roiEnable;	/**< Enable frame/row roi. */
  Uxi::RoiCoord	_roiRows;	/**< The first/last rows of the roi. */
  Uxi::RoiCoord	_roiFrames;	/**< The first/last frames of the roi. */
  uint32_t	_width;	/**< The width in pixels of each frame of the detector. */
  uint32_t	_height;	/**< The height in pixels of each frame of the detector. */
  uint32_t	_numberOfFrames;	/**< The number of frames produced by the detector. */
  uint32_t	_numberOfBytesPerPixel;	/**< The number of bytes for each pixel. */
  uint32_t	_sensorType;	/**< The sensor type ID. */
  uint32_t	_timeOn[NumberOfSides];	/**< High speed timing on parameter in ns for each side. */
  uint32_t	_timeOff[NumberOfSides];	/**< High speed timing off parameter in ns for each side. */
  uint32_t	_delay[NumberOfSides];	/**< High speed timing initial delay in ns for each side. */
  uint32_t	_readOnlyPots;	/**< Bitmask to designate which pots should only be read and not written. */
  double	_pots[NumberOfPots];	/**< The values of the each of the pots in volts. */
};
std::ostream& operator<<(std::ostream& str, Uxi::ConfigV2::RoiMode enval);
#pragma pack(pop)

/** @class ConfigV3

  
*/

#pragma pack(push,4)

class ConfigV3 {
public:
  enum { TypeId = Pds::TypeId::Id_UxiConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };
  enum { NumberOfPots = 13 /**< Defines the number of potentiometers in the Icarus detector. */ };
  enum { NumberOfSides = 2 };
  enum RoiMode {
    Off = 0,
    On = 1,
  };
  enum OscMode {
    RelaxationOsc = 0,
    RingOscWithCaps = 1,
    RingOscNoCaps = 2,
    ExternalClock = 3,
  };
  ConfigV3(Uxi::ConfigV3::RoiMode arg__roiEnable, const Uxi::RoiCoord& arg__roiRows, const Uxi::RoiCoord& arg__roiFrames, Uxi::ConfigV3::OscMode arg__oscillator, uint32_t arg__width, uint32_t arg__height, uint32_t arg__numberOfFrames, uint32_t arg__numberOfBytesPerPixel, uint32_t arg__sensorType, const uint32_t* arg__timeOn, const uint32_t* arg__timeOff, const uint32_t* arg__delay, uint32_t arg__readOnlyPots, const double* arg__pots);
  ConfigV3() {}
  ConfigV3(const ConfigV3& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV3& operator=(const ConfigV3& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Enable frame/row roi. */
  Uxi::ConfigV3::RoiMode roiEnable() const { return Uxi::ConfigV3::RoiMode(_roiEnable); }
  /** The first/last rows of the roi. */
  const Uxi::RoiCoord& roiRows() const { return _roiRows; }
  /** The first/last frames of the roi. */
  const Uxi::RoiCoord& roiFrames() const { return _roiFrames; }
  /** The oscillator to that the detector should use. */
  Uxi::ConfigV3::OscMode oscillator() const { return Uxi::ConfigV3::OscMode(_oscillator); }
  /** The width in pixels of each frame of the detector. */
  uint32_t width() const { return _width; }
  /** The height in pixels of each frame of the detector. */
  uint32_t height() const { return _height; }
  /** The number of frames produced by the detector. */
  uint32_t numberOfFrames() const { return _numberOfFrames; }
  /** The number of bytes for each pixel. */
  uint32_t numberOFBytesPerPixel() const { return _numberOfBytesPerPixel; }
  /** The sensor type ID. */
  uint32_t sensorType() const { return _sensorType; }
  /** High speed timing on parameter in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> timeOn(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_timeOn[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing on parameter in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> timeOn() const { return make_ndarray(&_timeOn[0], NumberOfSides); }
  /** High speed timing off parameter in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> timeOff(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_timeOff[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing off parameter in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> timeOff() const { return make_ndarray(&_timeOff[0], NumberOfSides); }
  /** High speed timing initial delay in ns for each side.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint32_t, 1> delay(const boost::shared_ptr<T>& owner) const { 
    const uint32_t* data = &_delay[0];
    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NumberOfSides);
  }
  /** High speed timing initial delay in ns for each side.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint32_t, 1> delay() const { return make_ndarray(&_delay[0], NumberOfSides); }
  /** Bitmask to designate which pots should only be read and not written. */
  uint32_t readOnlyPots() const { return _readOnlyPots; }
  /** The values of the each of the pots in volts.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> pots(const boost::shared_ptr<T>& owner) const { 
    const double* data = &_pots[0];
    return make_ndarray(boost::shared_ptr<const double>(owner, data), NumberOfPots);
  }
  /** The values of the each of the pots in volts.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> pots() const { return make_ndarray(&_pots[0], NumberOfPots); }
  /** Check if a pot is readonly. */
  uint8_t potIsReadOnly(uint8_t i) const { return ((i<NumberOfPots) && (_readOnlyPots & (1<<i))) ? 1 : 0; }
  /** Check if a pot was tuned. */
  uint8_t potIsTuned(uint8_t i) const { return ((i<NumberOfPots) && (_readOnlyPots & (1<<(i+NumberOfPots)))) ? 1 : 0; }
  /** calculate total number of pixels per frame. */
  uint32_t numPixelsPerFrame() const { return this->width()*this->height(); }
  /** calculate total number of pixels across all frames. */
  uint32_t numPixels() const { return this->width()*this->height()*this->numberOfFrames(); }
  /** Total size in bytes of the frame */
  uint32_t frameSize() const;
  static uint32_t _sizeof() { return ((((((((((((((((4+(Uxi::RoiCoord::_sizeof()))+(Uxi::RoiCoord::_sizeof()))+4)+4)+4)+4)+4)+4)+(4*(NumberOfSides)))+(4*(NumberOfSides)))+(4*(NumberOfSides)))+4)+(8*(NumberOfPots)))+4)-1)/4)*4; }
private:
  uint32_t	_roiEnable;	/**< Enable frame/row roi. */
  Uxi::RoiCoord	_roiRows;	/**< The first/last rows of the roi. */
  Uxi::RoiCoord	_roiFrames;	/**< The first/last frames of the roi. */
  uint32_t	_oscillator;	/**< The oscillator to that the detector should use. */
  uint32_t	_width;	/**< The width in pixels of each frame of the detector. */
  uint32_t	_height;	/**< The height in pixels of each frame of the detector. */
  uint32_t	_numberOfFrames;	/**< The number of frames produced by the detector. */
  uint32_t	_numberOfBytesPerPixel;	/**< The number of bytes for each pixel. */
  uint32_t	_sensorType;	/**< The sensor type ID. */
  uint32_t	_timeOn[NumberOfSides];	/**< High speed timing on parameter in ns for each side. */
  uint32_t	_timeOff[NumberOfSides];	/**< High speed timing off parameter in ns for each side. */
  uint32_t	_delay[NumberOfSides];	/**< High speed timing initial delay in ns for each side. */
  uint32_t	_readOnlyPots;	/**< Bitmask to designate which pots should only be read and not written. */
  double	_pots[NumberOfPots];	/**< The values of the each of the pots in volts. */
};
std::ostream& operator<<(std::ostream& str, Uxi::ConfigV3::RoiMode enval);
std::ostream& operator<<(std::ostream& str, Uxi::ConfigV3::OscMode enval);
#pragma pack(pop)

/** @class FrameV1

  
*/

class ConfigV1;
class ConfigV2;
class ConfigV3;
#pragma pack(push,2)

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UxiFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  FrameV1(uint32_t acquisitionCount, uint32_t timestamp, double temperature)
    : _acquisitionCount(acquisitionCount), _timestamp(timestamp), _temperature(temperature)
  {
  }
  FrameV1() {}
private:
  FrameV1(const FrameV1&);
  FrameV1& operator=(const FrameV1&);
public:
  /** The internal acquisition counter number of the detector. */
  uint32_t acquisitionCount() const { return _acquisitionCount; }
  /** The internal detector timestamp associated with the frames. */
  uint32_t timestamp() const { return _timestamp; }
  /** The temperature of the detector associated with the frames. */
  double temperature() const { return _temperature; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frames(const Uxi::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=16;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfFrames(), cfg.height(), cfg.width());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frames(const Uxi::ConfigV2& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=16;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfFrames(), cfg.height(), cfg.width());
  }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 3> frames(const Uxi::ConfigV3& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=16;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfFrames(), cfg.height(), cfg.width());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frames(const Uxi::ConfigV1& cfg) const { ptrdiff_t offset=16;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfFrames(), cfg.height(), cfg.width()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frames(const Uxi::ConfigV2& cfg) const { ptrdiff_t offset=16;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfFrames(), cfg.height(), cfg.width()); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 3> frames(const Uxi::ConfigV3& cfg) const { ptrdiff_t offset=16;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfFrames(), cfg.height(), cfg.width()); }
  static uint32_t _sizeof(const Uxi::ConfigV1& cfg) { return ((((16+(2*(cfg.numberOfFrames())*(cfg.height())*(cfg.width())))+2)-1)/2)*2; }
  static uint32_t _sizeof(const Uxi::ConfigV2& cfg) { return ((((16+(2*(cfg.numberOfFrames())*(cfg.height())*(cfg.width())))+2)-1)/2)*2; }
  static uint32_t _sizeof(const Uxi::ConfigV3& cfg) { return ((((16+(2*(cfg.numberOfFrames())*(cfg.height())*(cfg.width())))+2)-1)/2)*2; }
private:
  uint32_t	_acquisitionCount;	/**< The internal acquisition counter number of the detector. */
  uint32_t	_timestamp;	/**< The internal detector timestamp associated with the frames. */
  double	_temperature;	/**< The temperature of the detector associated with the frames. */
  //uint16_t	_frames[cfg.numberOfFrames()][cfg.height()][cfg.width()];
};
#pragma pack(pop)
} // namespace Uxi
} // namespace Pds
#endif // PDS_UXI_DDL_H
