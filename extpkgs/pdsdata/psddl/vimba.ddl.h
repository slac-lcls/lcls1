#ifndef PDS_VIMBA_DDL_H
#define PDS_VIMBA_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Vimba {

/** @class AlviumConfigV1

  
*/

#pragma pack(push,4)

class AlviumConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_AlviumConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { DESC_CHAR_MAX = 48 };
  enum VmbBool {
    False = 0,
    True = 1,
  };
  enum RoiMode {
    Off = 0,
    On = 1,
    Centered = 2,
  };
  enum TriggerMode {
    FreeRun = 0,
    External = 1,
    Software = 2,
  };
  enum PixelMode {
    Mono8 = 0,
    Mono10 = 1,
    Mono10p = 2,
    Mono12 = 3,
    Mono12p = 4,
  };
  enum ImgCorrectionType {
    DefectPixelCorrection = 0,
    FixedPatternNoiseCorrection = 1,
  };
  enum ImgCorrectionSet {
    Preset = 0,
    User = 1,
  };
  AlviumConfigV1(Vimba::AlviumConfigV1::VmbBool arg__reverseX, Vimba::AlviumConfigV1::VmbBool arg__reverseY, Vimba::AlviumConfigV1::VmbBool arg__contrastEnable, Vimba::AlviumConfigV1::VmbBool arg__correctionEnable, Vimba::AlviumConfigV1::RoiMode arg__roiEnable, Vimba::AlviumConfigV1::ImgCorrectionType arg__correctionType, Vimba::AlviumConfigV1::ImgCorrectionSet arg__correctionSet, Vimba::AlviumConfigV1::PixelMode arg__pixelMode, Vimba::AlviumConfigV1::TriggerMode arg__triggerMode, uint32_t arg__width, uint32_t arg__height, uint32_t arg__offsetX, uint32_t arg__offsetY, uint32_t arg__sensorWidth, uint32_t arg__sensorHeight, uint32_t arg__contrastDarkLimit, uint32_t arg__contrastBrightLimit, uint32_t arg__contrastShape, double arg__exposureTime, double arg__blackLevel, double arg__gain, double arg__gamma, const char* arg__manufacturer, const char* arg__family, const char* arg__model, const char* arg__manufacturerId, const char* arg__version, const char* arg__serialNumber, const char* arg__firmwareId, const char* arg__firmwareVersion)
    : _reverseX(arg__reverseX), _reverseY(arg__reverseY), _contrastEnable(arg__contrastEnable), _correctionEnable(arg__correctionEnable), _roiEnable(arg__roiEnable), _correctionType(arg__correctionType), _correctionSet(arg__correctionSet), _pixelMode(arg__pixelMode), _triggerMode(arg__triggerMode), _width(arg__width), _height(arg__height), _offsetX(arg__offsetX), _offsetY(arg__offsetY), _sensorWidth(arg__sensorWidth), _sensorHeight(arg__sensorHeight), _contrastDarkLimit(arg__contrastDarkLimit), _contrastBrightLimit(arg__contrastBrightLimit), _contrastShape(arg__contrastShape), _exposureTime(arg__exposureTime), _blackLevel(arg__blackLevel), _gain(arg__gain), _gamma(arg__gamma)
  {
    if (arg__manufacturer) std::copy(arg__manufacturer, arg__manufacturer+(48), &_manufacturer[0]);
    if (arg__family) std::copy(arg__family, arg__family+(48), &_family[0]);
    if (arg__model) std::copy(arg__model, arg__model+(48), &_model[0]);
    if (arg__manufacturerId) std::copy(arg__manufacturerId, arg__manufacturerId+(48), &_manufacturerId[0]);
    if (arg__version) std::copy(arg__version, arg__version+(48), &_version[0]);
    if (arg__serialNumber) std::copy(arg__serialNumber, arg__serialNumber+(48), &_serialNumber[0]);
    if (arg__firmwareId) std::copy(arg__firmwareId, arg__firmwareId+(48), &_firmwareId[0]);
    if (arg__firmwareVersion) std::copy(arg__firmwareVersion, arg__firmwareVersion+(48), &_firmwareVersion[0]);
  }
  AlviumConfigV1() {}
  AlviumConfigV1(const AlviumConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  AlviumConfigV1& operator=(const AlviumConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Reverse the image along the x-axis of the image. */
  Vimba::AlviumConfigV1::VmbBool reverseX() const { return Vimba::AlviumConfigV1::VmbBool(_reverseX); }
  /** Reverse the image along the y-axis of the image. */
  Vimba::AlviumConfigV1::VmbBool reverseY() const { return Vimba::AlviumConfigV1::VmbBool(_reverseY); }
  /** Enable contrast enhancement features. */
  Vimba::AlviumConfigV1::VmbBool contrastEnable() const { return Vimba::AlviumConfigV1::VmbBool(_contrastEnable); }
  /** Enable image correction feature. */
  Vimba::AlviumConfigV1::VmbBool correctionEnable() const { return Vimba::AlviumConfigV1::VmbBool(_correctionEnable); }
  /** Enable image roi. */
  Vimba::AlviumConfigV1::RoiMode roiEnable() const { return Vimba::AlviumConfigV1::RoiMode(_roiEnable); }
  /** Sets the type of image correction to use. */
  Vimba::AlviumConfigV1::ImgCorrectionType correctionType() const { return Vimba::AlviumConfigV1::ImgCorrectionType(_correctionType); }
  /** Sets which image correction date to use. */
  Vimba::AlviumConfigV1::ImgCorrectionSet correctionSet() const { return Vimba::AlviumConfigV1::ImgCorrectionSet(_correctionSet); }
  /** Sets the pixel bit depth. */
  Vimba::AlviumConfigV1::PixelMode pixelMode() const { return Vimba::AlviumConfigV1::PixelMode(_pixelMode); }
  /** Sets the trigger mode. */
  Vimba::AlviumConfigV1::TriggerMode triggerMode() const { return Vimba::AlviumConfigV1::TriggerMode(_triggerMode); }
  uint32_t width() const { return _width; }
  uint32_t height() const { return _height; }
  uint32_t offsetX() const { return _offsetX; }
  uint32_t offsetY() const { return _offsetY; }
  uint32_t sensorWidth() const { return _sensorWidth; }
  uint32_t sensorHeight() const { return _sensorHeight; }
  uint32_t contrastDarkLimit() const { return _contrastDarkLimit; }
  uint32_t contrastBrightLimit() const { return _contrastBrightLimit; }
  uint32_t contrastShape() const { return _contrastShape; }
  double exposureTime() const { return _exposureTime; }
  double blackLevel() const { return _blackLevel; }
  double gain() const { return _gain; }
  double gamma() const { return _gamma; }
  /** The name of the manufacturer of the camera. */
  const char* manufacturer() const { return _manufacturer; }
  /** The model family of the camera. */
  const char* family() const { return _family; }
  /** The model name of the camera. */
  const char* model() const { return _model; }
  /** The manufacturer id of the camera. */
  const char* manufacturerId() const { return _manufacturerId; }
  /** The hardware version number of the camera. */
  const char* version() const { return _version; }
  /** The serial number of the camera. */
  const char* serialNumber() const { return _serialNumber; }
  /** The firmware id of the camera. */
  const char* firmwareId() const { return _firmwareId; }
  /** The firmware version of the camera. */
  const char* firmwareVersion() const { return _firmwareVersion; }
  /** Number of bits per pixel. */
  uint32_t depth() const;
  /** Total size in bytes of the Frame object */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI */
  uint32_t numPixelsX() const { return width(); }
  /** calculate frame Y size in pixels based on the current ROI */
  uint32_t numPixelsY() const { return height(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return numPixelsX()*numPixelsY(); }
  static uint32_t _sizeof() { return (((((((((((((((((((((((((((((5+(1*(3)))+1)+1)+1)+1)+4)+4)+4)+4)+4)+4)+4)+4)+4)+8)+8)+8)+8)+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+(1*(DESC_CHAR_MAX)))+4)-1)/4)*4; }
private:
  uint8_t	_reverseX;	/**< Reverse the image along the x-axis of the image. */
  uint8_t	_reverseY;	/**< Reverse the image along the y-axis of the image. */
  uint8_t	_contrastEnable;	/**< Enable contrast enhancement features. */
  uint8_t	_correctionEnable;	/**< Enable image correction feature. */
  uint8_t	_roiEnable;	/**< Enable image roi. */
  uint8_t	_pad0[3];
  uint8_t	_correctionType;	/**< Sets the type of image correction to use. */
  uint8_t	_correctionSet;	/**< Sets which image correction date to use. */
  uint8_t	_pixelMode;	/**< Sets the pixel bit depth. */
  uint8_t	_triggerMode;	/**< Sets the trigger mode. */
  uint32_t	_width;
  uint32_t	_height;
  uint32_t	_offsetX;
  uint32_t	_offsetY;
  uint32_t	_sensorWidth;
  uint32_t	_sensorHeight;
  uint32_t	_contrastDarkLimit;
  uint32_t	_contrastBrightLimit;
  uint32_t	_contrastShape;
  double	_exposureTime;
  double	_blackLevel;
  double	_gain;
  double	_gamma;
  char	_manufacturer[DESC_CHAR_MAX];	/**< The name of the manufacturer of the camera. */
  char	_family[DESC_CHAR_MAX];	/**< The model family of the camera. */
  char	_model[DESC_CHAR_MAX];	/**< The model name of the camera. */
  char	_manufacturerId[DESC_CHAR_MAX];	/**< The manufacturer id of the camera. */
  char	_version[DESC_CHAR_MAX];	/**< The hardware version number of the camera. */
  char	_serialNumber[DESC_CHAR_MAX];	/**< The serial number of the camera. */
  char	_firmwareId[DESC_CHAR_MAX];	/**< The firmware id of the camera. */
  char	_firmwareVersion[DESC_CHAR_MAX];	/**< The firmware version of the camera. */
};
std::ostream& operator<<(std::ostream& str, Vimba::AlviumConfigV1::VmbBool enval);
std::ostream& operator<<(std::ostream& str, Vimba::AlviumConfigV1::RoiMode enval);
std::ostream& operator<<(std::ostream& str, Vimba::AlviumConfigV1::TriggerMode enval);
std::ostream& operator<<(std::ostream& str, Vimba::AlviumConfigV1::PixelMode enval);
std::ostream& operator<<(std::ostream& str, Vimba::AlviumConfigV1::ImgCorrectionType enval);
std::ostream& operator<<(std::ostream& str, Vimba::AlviumConfigV1::ImgCorrectionSet enval);
#pragma pack(pop)

/** @class FrameV1

  
*/

class AlviumConfigV1;
#pragma pack(push,2)

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_VimbaFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  FrameV1(uint64_t frameid, uint64_t timestamp)
    : _frameid(frameid), _timestamp(timestamp)
  {
  }
  FrameV1() {}
private:
  FrameV1(const FrameV1&);
  FrameV1& operator=(const FrameV1&);
public:
  /** The internal frame id from the camera. */
  uint64_t frameid() const { return _frameid; }
  /** The internal camera FPGA clock timestamp for the frame. */
  uint64_t timestamp() const { return _timestamp; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> data(const Vimba::AlviumConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=16;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numPixelsY(), cfg.numPixelsX());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> data(const Vimba::AlviumConfigV1& cfg) const { ptrdiff_t offset=16;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  static uint32_t _sizeof(const Vimba::AlviumConfigV1& cfg) { return ((((16+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+2)-1)/2)*2; }
private:
  uint64_t	_frameid;	/**< The internal frame id from the camera. */
  uint64_t	_timestamp;	/**< The internal camera FPGA clock timestamp for the frame. */
  //uint16_t	_data[cfg.numPixelsY()][cfg.numPixelsX()];
};
#pragma pack(pop)
} // namespace Vimba
} // namespace Pds
#endif // PDS_VIMBA_DDL_H
