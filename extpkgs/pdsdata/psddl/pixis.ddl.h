#ifndef PDS_PIXIS_DDL_H
#define PDS_PIXIS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Pixis {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PixisConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum GainMode {
    Low = 1,
    Medium = 2,
    High = 3,
  };
  enum AdcMode {
    LowNoise = 1,
    HighCapacity = 2,
  };
  enum TriggerMode {
    Software = 0,
    External = 1,
    ExternalWithCleaning = 2,
  };
  ConfigV1(uint32_t arg__width, uint32_t arg__height, uint32_t arg__orgX, uint32_t arg__orgY, uint32_t arg__binX, uint32_t arg__binY, float arg__exposureTime, float arg__coolingTemp, float arg__readoutSpeed, Pixis::ConfigV1::GainMode arg__gainMode, Pixis::ConfigV1::AdcMode arg__adcMode, Pixis::ConfigV1::TriggerMode arg__triggerMode, uint32_t arg__activeWidth, uint32_t arg__activeHeight, uint32_t arg__activeTopMargin, uint32_t arg__activeBottomMargin, uint32_t arg__activeLeftMargin, uint32_t arg__activeRightMargin, uint32_t arg__cleanCycleCount, uint32_t arg__cleanCycleHeight, uint32_t arg__cleanFinalHeight, uint32_t arg__cleanFinalHeightCount, uint32_t arg__maskedHeight, uint32_t arg__kineticHeight, float arg__vsSpeed, int16_t arg__infoReportInterval, uint16_t arg__exposureEventCode, uint32_t arg__numIntegrationShots)
    : _width(arg__width), _height(arg__height), _orgX(arg__orgX), _orgY(arg__orgY), _binX(arg__binX), _binY(arg__binY), _exposureTime(arg__exposureTime), _coolingTemp(arg__coolingTemp), _readoutSpeed(arg__readoutSpeed), _gainMode(arg__gainMode), _adcMode(arg__adcMode), _triggerMode(arg__triggerMode), _activeWidth(arg__activeWidth), _activeHeight(arg__activeHeight), _activeTopMargin(arg__activeTopMargin), _activeBottomMargin(arg__activeBottomMargin), _activeLeftMargin(arg__activeLeftMargin), _activeRightMargin(arg__activeRightMargin), _cleanCycleCount(arg__cleanCycleCount), _cleanCycleHeight(arg__cleanCycleHeight), _cleanFinalHeight(arg__cleanFinalHeight), _cleanFinalHeightCount(arg__cleanFinalHeightCount), _maskedHeight(arg__maskedHeight), _kineticHeight(arg__kineticHeight), _vsSpeed(arg__vsSpeed), _infoReportInterval(arg__infoReportInterval), _exposureEventCode(arg__exposureEventCode), _numIntegrationShots(arg__numIntegrationShots)
  {
  }
  ConfigV1(uint32_t width, uint32_t height)
    : _width(width), _height(height)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t width() const { return _width; }
  uint32_t height() const { return _height; }
  uint32_t orgX() const { return _orgX; }
  uint32_t orgY() const { return _orgY; }
  uint32_t binX() const { return _binX; }
  uint32_t binY() const { return _binY; }
  /** Detector exposure time in seconds. */
  float exposureTime() const { return _exposureTime; }
  /** Detector cooler setpoint temperature in degrees Celsius. */
  float coolingTemp() const { return _coolingTemp; }
  /** Detector ADC digitization speed in MHz. */
  float readoutSpeed() const { return _readoutSpeed; }
  /** Enum of the available gain settings of the detector. */
  Pixis::ConfigV1::GainMode gainMode() const { return Pixis::ConfigV1::GainMode(_gainMode); }
  /** Enum of the available ADC Quality settings of the detector. */
  Pixis::ConfigV1::AdcMode adcMode() const { return Pixis::ConfigV1::AdcMode(_adcMode); }
  /** Trigger setting for the detector. */
  Pixis::ConfigV1::TriggerMode triggerMode() const { return Pixis::ConfigV1::TriggerMode(_triggerMode); }
  /** Detector active width in columns. */
  uint32_t activeWidth() const { return _activeWidth; }
  /** Detector active height in rows. */
  uint32_t activeHeight() const { return _activeHeight; }
  /** Number of inactive rows at the top of the sensor. */
  uint32_t activeTopMargin() const { return _activeTopMargin; }
  /** Number of inactive rows at the top of the sensor. */
  uint32_t activeBottomMargin() const { return _activeBottomMargin; }
  /** Number of inactive columns at the left of the sensor. */
  uint32_t activeLeftMargin() const { return _activeLeftMargin; }
  /** Number of inactive columns at the right of the sensor. */
  uint32_t activeRightMargin() const { return _activeRightMargin; }
  /** The number of clean cycles to run before acquisition begins. */
  uint32_t cleanCycleCount() const { return _cleanCycleCount; }
  /** The number of rows in a clean cycle. */
  uint32_t cleanCycleHeight() const { return _cleanCycleHeight; }
  /** The final height rows for exponential decomposition cleaning. */
  uint32_t cleanFinalHeight() const { return _cleanFinalHeight; }
  /** The final height iterations for exponential decomposition cleaning. */
  uint32_t cleanFinalHeightCount() const { return _cleanFinalHeightCount; }
  uint32_t maskedHeight() const { return _maskedHeight; }
  uint32_t kineticHeight() const { return _kineticHeight; }
  /** Detector vertical shift speed. */
  float vsSpeed() const { return _vsSpeed; }
  int16_t infoReportInterval() const { return _infoReportInterval; }
  uint16_t exposureEventCode() const { return _exposureEventCode; }
  uint32_t numIntegrationShots() const { return _numIntegrationShots; }
  /** Total size in bytes of the Frame object */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (this->width() + this->binX() - 1) / this->binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (this->height()+ this->binY() - 1) / this->binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { 
    return ((this->width() + this->binX()-1)/ this->binX() )*((this->height()+ this->binY()-1)/ this->binY() );
 }
  static uint32_t _sizeof() { return 104; }
private:
  uint32_t	_width;
  uint32_t	_height;
  uint32_t	_orgX;
  uint32_t	_orgY;
  uint32_t	_binX;
  uint32_t	_binY;
  float	_exposureTime;	/**< Detector exposure time in seconds. */
  float	_coolingTemp;	/**< Detector cooler setpoint temperature in degrees Celsius. */
  float	_readoutSpeed;	/**< Detector ADC digitization speed in MHz. */
  uint16_t	_gainMode;	/**< Enum of the available gain settings of the detector. */
  uint16_t	_adcMode;	/**< Enum of the available ADC Quality settings of the detector. */
  uint16_t	_triggerMode;	/**< Trigger setting for the detector. */
  uint16_t	_pad0;
  uint32_t	_activeWidth;	/**< Detector active width in columns. */
  uint32_t	_activeHeight;	/**< Detector active height in rows. */
  uint32_t	_activeTopMargin;	/**< Number of inactive rows at the top of the sensor. */
  uint32_t	_activeBottomMargin;	/**< Number of inactive rows at the top of the sensor. */
  uint32_t	_activeLeftMargin;	/**< Number of inactive columns at the left of the sensor. */
  uint32_t	_activeRightMargin;	/**< Number of inactive columns at the right of the sensor. */
  uint32_t	_cleanCycleCount;	/**< The number of clean cycles to run before acquisition begins. */
  uint32_t	_cleanCycleHeight;	/**< The number of rows in a clean cycle. */
  uint32_t	_cleanFinalHeight;	/**< The final height rows for exponential decomposition cleaning. */
  uint32_t	_cleanFinalHeightCount;	/**< The final height iterations for exponential decomposition cleaning. */
  uint32_t	_maskedHeight;
  uint32_t	_kineticHeight;
  float	_vsSpeed;	/**< Detector vertical shift speed. */
  int16_t	_infoReportInterval;
  uint16_t	_exposureEventCode;
  uint32_t	_numIntegrationShots;
};
std::ostream& operator<<(std::ostream& str, Pixis::ConfigV1::GainMode enval);
std::ostream& operator<<(std::ostream& str, Pixis::ConfigV1::AdcMode enval);
std::ostream& operator<<(std::ostream& str, Pixis::ConfigV1::TriggerMode enval);
#pragma pack(pop)

/** @class FrameV1

  
*/

class ConfigV1;
#pragma pack(push,4)

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PixisFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  FrameV1(uint32_t iShotIdStart, float fReadoutTime, float fTemperature)
    : _iShotIdStart(iShotIdStart), _fReadoutTime(fReadoutTime), _fTemperature(fTemperature)
  {
  }
  FrameV1() {}
private:
  FrameV1(const FrameV1&);
  FrameV1& operator=(const FrameV1&);
public:
  uint32_t shotIdStart() const { return _iShotIdStart; }
  float readoutTime() const { return _fReadoutTime; }
  float temperature() const { return _fTemperature; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> data(const Pixis::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=12;
    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numPixelsY(), cfg.numPixelsX());
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> data(const Pixis::ConfigV1& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  static uint32_t _sizeof(const Pixis::ConfigV1& cfg) { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
private:
  uint32_t	_iShotIdStart;
  float	_fReadoutTime;
  float	_fTemperature;
  //uint16_t	_data[cfg.numPixelsY()][cfg.numPixelsX()];
};
#pragma pack(pop)
} // namespace Pixis
} // namespace Pds
#endif // PDS_PIXIS_DDL_H
