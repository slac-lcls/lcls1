#ifndef PDS_RAYONIX_DDL_H
#define PDS_RAYONIX_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace Rayonix {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_RayonixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Row_Pixels = 3840 };
  enum { Column_Pixels = 3840 };
  enum { BasePixelSize = 44 };
  enum { DeviceIDMax = 40 };
  enum ReadoutMode {
    Standard = 0,
    HighGain = 1,
    LowNoise = 2,
    EDR = 3,
  };
  ConfigV1(uint8_t arg__binning_f, uint8_t arg__binning_s, uint32_t arg__exposure, uint32_t arg__trigger, uint16_t arg__rawMode, uint16_t arg__darkFlag, Rayonix::ConfigV1::ReadoutMode arg__readoutMode, const char* arg__deviceID)
    : _binning_f(arg__binning_f), _binning_s(arg__binning_s), _exposure(arg__exposure), _trigger(arg__trigger), _rawMode(arg__rawMode), _darkFlag(arg__darkFlag), _readoutMode(arg__readoutMode)
  {
    if (arg__deviceID) std::copy(arg__deviceID, arg__deviceID+(40), &_deviceID[0]);
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t binning_f() const { return _binning_f; }
  uint8_t binning_s() const { return _binning_s; }
  uint32_t exposure() const { return _exposure; }
  uint32_t trigger() const { return _trigger; }
  uint16_t rawMode() const { return _rawMode; }
  uint16_t darkFlag() const { return _darkFlag; }
  Rayonix::ConfigV1::ReadoutMode readoutMode() const { return Rayonix::ConfigV1::ReadoutMode(_readoutMode); }
  const char* deviceID() const { return _deviceID; }
  /** The width of the pixels in um. */
  uint32_t pixelWidth() const { return BasePixelSize * this->binning_f(); }
  /** The height of the pixels in um. */
  uint32_t pixelHeight() const { return BasePixelSize * this->binning_s(); }
  /** Returns the maximum possible width in pixels (a.k.a unbinned). */
  uint32_t maxWidth() const { return Column_Pixels; }
  /** Returns the maximum possible height in pixels (a.k.a unbinned). */
  uint32_t maxHeight() const { return Row_Pixels; }
  /** Calculate the frame width in pixels based on the max number of pixels and the binning. */
  uint32_t width() const { return this->maxWidth() / this->binning_f(); }
  /** Calculate the frame height in pixels based on the max number of pixels and the binning. */
  uint32_t height() const { return this->maxHeight() / this->binning_s(); }
  /** calculate total frame size in pixels. */
  uint32_t numPixels() const { return this->width() * this->height(); }
  static uint32_t _sizeof() { return ((((20+(1*(DeviceIDMax)))+4)-1)/4)*4; }
private:
  uint8_t	_binning_f;
  uint8_t	_binning_s;
  int16_t	_pad;
  uint32_t	_exposure;
  uint32_t	_trigger;
  uint16_t	_rawMode;
  uint16_t	_darkFlag;
  uint32_t	_readoutMode;
  char	_deviceID[DeviceIDMax];
};
std::ostream& operator<<(std::ostream& str, Rayonix::ConfigV1::ReadoutMode enval);
#pragma pack(pop)

/** @class ConfigV2

  
*/

#pragma pack(push,4)

class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_RayonixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { MX340HS_Row_Pixels = 7680 };
  enum { MX340HS_Column_Pixels = 7680 };
  enum { MX170HS_Row_Pixels = 3840 };
  enum { MX170HS_Column_Pixels = 3840 };
  enum { BasePixelSize = 44 };
  enum { DeviceIDMax = 40 };
  enum ReadoutMode {
    Unknown = 0,
    Standard = 1,
    HighGain = 2,
    LowNoise = 3,
    HDR = 4,
  };
  ConfigV2(uint8_t arg__binning_f, uint8_t arg__binning_s, int16_t arg__testPattern, uint32_t arg__exposure, uint32_t arg__trigger, uint16_t arg__rawMode, uint16_t arg__darkFlag, Rayonix::ConfigV2::ReadoutMode arg__readoutMode, const char* arg__deviceID)
    : _binning_f(arg__binning_f), _binning_s(arg__binning_s), _testPattern(arg__testPattern), _exposure(arg__exposure), _trigger(arg__trigger), _rawMode(arg__rawMode), _darkFlag(arg__darkFlag), _readoutMode(arg__readoutMode)
  {
    if (arg__deviceID) std::copy(arg__deviceID, arg__deviceID+(40), &_deviceID[0]);
  }
  ConfigV2() {}
  ConfigV2(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV2& operator=(const ConfigV2& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t binning_f() const { return _binning_f; }
  uint8_t binning_s() const { return _binning_s; }
  int16_t testPattern() const { return _testPattern; }
  uint32_t exposure() const { return _exposure; }
  uint32_t trigger() const { return _trigger; }
  uint16_t rawMode() const { return _rawMode; }
  uint16_t darkFlag() const { return _darkFlag; }
  Rayonix::ConfigV2::ReadoutMode readoutMode() const { return Rayonix::ConfigV2::ReadoutMode(_readoutMode); }
  const char* deviceID() const { return _deviceID; }
  /** The width of the pixels in um. */
  uint32_t pixelWidth() const { return BasePixelSize * this->binning_f(); }
  /** The height of the pixels in um. */
  uint32_t pixelHeight() const { return BasePixelSize * this->binning_s(); }
  /** Returns the maximum possible width in pixels (a.k.a unbinned). */
  uint32_t maxWidth() const;
  /** Returns the maximum possible height in pixels (a.k.a unbinned). */
  uint32_t maxHeight() const;
  /** Calculate the frame width in pixels based on the max number of pixels and the binning. */
  uint32_t width() const { return this->maxWidth() / this->binning_f(); }
  /** Calculate the frame height in pixels based on the max number of pixels and the binning. */
  uint32_t height() const { return this->maxHeight() / this->binning_s(); }
  /** calculate total frame size in pixels. */
  uint32_t numPixels() const { return this->width() * this->height(); }
  static uint32_t _sizeof() { return ((((20+(1*(DeviceIDMax)))+4)-1)/4)*4; }
private:
  uint8_t	_binning_f;
  uint8_t	_binning_s;
  int16_t	_testPattern;
  uint32_t	_exposure;
  uint32_t	_trigger;
  uint16_t	_rawMode;
  uint16_t	_darkFlag;
  uint32_t	_readoutMode;
  char	_deviceID[DeviceIDMax];
};
std::ostream& operator<<(std::ostream& str, Rayonix::ConfigV2::ReadoutMode enval);
#pragma pack(pop)
} // namespace Rayonix
} // namespace Pds
#endif // PDS_RAYONIX_DDL_H
